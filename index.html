<!DOCTYPE html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta property="og:image" content="https://smysl.io/img/og.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Anonymous+Pro|PT+Mono"><link rel="stylesheet" href="/fonts/font-awesome-4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="/css/glow.css"><link rel="stylesheet" href="/css/lessons-pointer.css"><link rel="stylesheet" href="/css/social-likes_birman.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/landing.css"><link rel="stylesheet" href="/css/blog.css"><link rel="apple-touch-icon-precomposed" sizes="57x57" href="img/favicons/apple-touch-icon-57x57.png"><link rel="apple-touch-icon-precomposed" sizes="114x114" href="img/favicons/apple-touch-icon-114x114.png"><link rel="apple-touch-icon-precomposed" sizes="72x72" href="img/favicons/apple-touch-icon-72x72.png"><link rel="apple-touch-icon-precomposed" sizes="144x144" href="img/favicons/apple-touch-icon-144x144.png"><link rel="apple-touch-icon-precomposed" sizes="60x60" href="img/favicons/apple-touch-icon-60x60.png"><link rel="apple-touch-icon-precomposed" sizes="120x120" href="img/favicons/apple-touch-icon-120x120.png"><link rel="apple-touch-icon-precomposed" sizes="76x76" href="img/favicons/apple-touch-icon-76x76.png"><link rel="apple-touch-icon-precomposed" sizes="152x152" href="img/favicons/apple-touch-icon-152x152.png"><link rel="icon" type="image/png" href="img/favicons/favicon-196x196.png" sizes="196x196"><link rel="icon" type="image/png" href="img/favicons/favicon-96x96.png" sizes="96x96"><link rel="icon" type="image/png" href="img/favicons/favicon-32x32.png" sizes="32x32"><link rel="icon" type="image/png" href="img/favicons/favicon-16x16.png" sizes="16x16"><link rel="icon" type="image/png" href="img/favicons/favicon-128.png" sizes="128x128"><meta name="application-name" content=" "><meta name="msapplication-TileColor" content="#FFFFFF"><meta name="msapplication-TileImage" content="img/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="mg/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="img/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="img/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="img/favicons/mstile-310x310.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="jS-UOFLu8isjqw3UjLkGEP-fD-tG7w7cAMLIeSepC7M"><meta name="yandex-verification" content="3365363b8d7940a9"><link rel="icon" href="http://ono38scfe.bkt.clouddn.com/favicon_tree.ico"><link rel="icon" type="image/png" sizes="16x16" href="undefined"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-MS47VNR');</script><title>Сайт Алексея Куличевского</title><meta name="generator" content="Hexo 5.3.0"></head><body><!-- - Google Tag Manager (noscript)--><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-MS47VNR" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><!-- - End Google Tag Manager (noscript)--><div class="container"><div id="content-outer"><div id="content-inner"><div class="blog"><div class="container"><div class="row"><div class="col-md-8 col-sm-12"><div class="avatar"><span><img src="https://s.gravatar.com/avatar/e574dc154e694d72dc40e1dc9be17c32?s=80" width="40px" height="40px"></span><span class="author_name">Алексей Куличевский            <span style="font-family: graphik-regular;">Блог · <a class="header" href="https://t.me/kulichevskiy" target="_blank">Телеграм</a> · <a class="header" href="/courses/data-1">Курс</a></span></span></div></div></div></div><div id="recent-posts"><div class="container container_margin"><div class="row"><div class="col-md-8 col-sm-12"><h1><a href="/blog/pandas-cohorts/">Когортный анализ в Pandas</a></h1><blockquote>
<p>Привет! Продолжем изучать Pandas. В&nbsp;прошлый раз я&nbsp;<a href="http://smysl.io/blog/pandas/">рассказал о&nbsp;возможностях библиотеки </a>, а&nbsp;сегодня покажу, как с&nbsp;её помощью делать когортный анализ.</p>
</blockquote>
<p>Прежде всего, вспомним, что такое когорты и&nbsp;как их&nbsp;анализировать.</p>
<div style="padding: 1rem 1rem 0 1rem;"><p style="font-family: graphik-regular; font-size: .9rem;">Когорта&nbsp;&mdash; это группа людей, которая совершила нужное действие в&nbsp;определенный промежуток времени.</p><p style="font-family: graphik-regular; font-size: .9rem;">Когортный анализ&nbsp;&mdash; это наблюдение за&nbsp;когортами. Выбираем одну или несколько метрик, измеряем их&nbsp;и&nbsp;делаем выводы.</p><br></div>

<p>Например, социологи могут отслеживать, сколько людей, родившихся в&nbsp;1980 году, получили высшее образование. Когорта здесь&nbsp;&mdash; те, кто родились в&nbsp;1980 году. Метрика&nbsp;&mdash; доля людей с&nbsp;высшим образованием.</p>
<p>Еще пример: маркетологи хотят узнать, сколько заказов и&nbsp;выручки принесли пользователи, совершившие свой первый заказ год назад. Теперь когорта&nbsp;&mdash; это прошлогодние покупатели, а&nbsp;метрики&nbsp;&mdash; количество заказов и&nbsp;выручка.</p>
<p>Получается, когортный анализ состоит из&nbsp;трех шагов: определения нужного действия и&nbsp;временного промежутка когорты и&nbsp;выбора метрик для отслеживания:</p>
<table>
<thead>
<tr>
<th style="text-align:left">Действие</th>
<th style="text-align:left">Время</th>
<th style="text-align:left">Метрика</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Родились</td>
<td style="text-align:left">В&nbsp;1980 году</td>
<td style="text-align:left">% людей с&nbsp;высшим образованием</td>
</tr>
<tr>
<td style="text-align:left">Впервые <nobr>что-то</nobr> купили</td>
<td style="text-align:left">Год назад</td>
<td style="text-align:left">Количество заказов и&nbsp;выручка</td>
</tr>
<tr>
<td style="text-align:left">Установили приложение</td>
<td style="text-align:left">Неделю назад</td>
<td style="text-align:left">% пользователей, открывших приложение еще раз</td>
</tr>
</tbody>
</table>
<p>Когорты можно сравнивать между собой. Например, маркетологи измеряют, сколько заказов обычно делают пользователи в&nbsp;течение месяца после первой покупки и&nbsp;смотрят динамику:</p>
<table>
<thead>
<tr>
<th style="text-align:left">Месяц</th>
<th style="text-align:right">Клиенты</th>
<th style="text-align:right">Покупок в&nbsp;1й месяц</th>
<th style="text-align:right">Покупок на&nbsp;клиента</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Январь 2018</td>
<td style="text-align:right">134</td>
<td style="text-align:right">161</td>
<td style="text-align:right">1.20</td>
</tr>
<tr>
<td style="text-align:left">Февраль 2018</td>
<td style="text-align:right">164</td>
<td style="text-align:right">194</td>
<td style="text-align:right">1.18</td>
</tr>
<tr>
<td style="text-align:left">Март 2018</td>
<td style="text-align:right"><span class="green"><strong>193</strong></span></td>
<td style="text-align:right"><span class="green"><strong>200</strong></span></td>
<td style="text-align:right"><span class="red"><strong>1.03</strong></span></td>
</tr>
</tbody>
</table>
<p>Общее количество клиентов и&nbsp;покупок выросло&nbsp;&mdash; приятно. Но, сравнив когорты, видим, что в&nbsp;среднем клиенты стали покупать реже&nbsp;&mdash; тревожный знак.</p>
<p>Ок, теперь мы&nbsp;готовы к&nbsp;тому, чтобы научиться делать когортный анализ с&nbsp;помощью Pandas. Для наглядности решим задачу.</p>
<h2 id="Задача"><a href="#Задача" class="headerlink" title="Задача"></a>Задача</h2><p>Допустим, мы&nbsp;работаем в&nbsp;<nobr>интернет-магазине</nobr> и&nbsp;хотим понять, сколько заказов и&nbsp;денег клиенты приносят в&nbsp;течение года после первой покупки. Для этого у&nbsp;нас есть <a href="http://smysl.io/data/pandas/orders.csv">данные о&nbsp;заказах</a>:</p>
<script src="https://gist.github.com/kulichevskiy/867460c17cb66d5860cebd5964b231ec.js"></script>

<p>Каждая строка таблицы <code>orders</code>&nbsp;&mdash; это покупка. Мы&nbsp;знаем, когда она произошла, кто её сделал и&nbsp;сколько денег она принесла в&nbsp;магазин. Дата заказа лежит в&nbsp;поле <code>order_date</code>, номер покупателя&nbsp;&mdash; в&nbsp;<code>customer_id</code>, а&nbsp;выручка&nbsp;&mdash; в&nbsp;<code>sales</code>.</p>
<p>Часто бывает, что даты загружаются в&nbsp;виде текста. Преобразим колонку <code>order_date</code> из&nbsp;текста в&nbsp;дату:</p>
<script src="https://gist.github.com/kulichevskiy/5f49b1d5a58884b4f4666d28a1fc37c2.js"></script>

<p>Данные перед нами, теперь можно с&nbsp;ними работать. Начнем с&nbsp;простого: выясним, сколько всего в&nbsp;магазине было покупок и&nbsp;выручки.</p>
<h2 id="Считаем-покупки-и-nbsp-выручку"><a href="#Считаем-покупки-и-nbsp-выручку" class="headerlink" title="Считаем покупки и&nbsp;выручку"></a>Считаем покупки и&nbsp;выручку</h2><p>Чтобы посчитать общую выручку, просуммируем колонку <code>sales</code>:</p>
<script src="https://gist.github.com/kulichevskiy/5b510516c6cc33179c743d348b9bc01b.js"></script>

<p>Количество заказов можно посчитать с&nbsp;помощью этой&nbsp;же колонки, но&nbsp;вместо суммы используем метод <code>count()</code>:</p>
<script src="https://gist.github.com/kulichevskiy/ef1321544a45b172c589062bf9d0a396.js"></script>

<p>Теперь посчитаем обе метрики для каждого пользователя. Сгруппируем датафрейм по&nbsp;полю <code>customer_id</code>:</p>
<script src="https://gist.github.com/kulichevskiy/6c754554a2b96e7fe9ce8530042059f5.js"></script>

<p>Видим, например, что пользователь AA-10315 сделал 5 заказов и&nbsp;принес $5563 выручки.</p>
<p>Идём дальше. Чтобы построить когорты, нам нужно сгруппировать клиентов по&nbsp;дате их&nbsp;первой покупки. В&nbsp;данных нет такого поля, значит, нужно его посчитать.</p>
<h2 id="Считаем-дату-первой-покупки"><a href="#Считаем-дату-первой-покупки" class="headerlink" title="Считаем дату первой покупки"></a>Считаем дату первой покупки</h2><p>Чтобы вычислить дату первой покупки каждого пользователя, сгруппируем данные по&nbsp;<code>customer_id</code> и&nbsp;найдем минимальное значение поля <code>order_date</code>. Результат сохраним в&nbsp;переменную <code>first_orders</code>:</p>
<script src="https://gist.github.com/kulichevskiy/15683789197f08e2fda93b6b708396a8.js"></script>

<p>Видим, что пользовать AA-10315 впервые что-то купил 31&nbsp;марта 2014 года, а&nbsp;пользователь AA-10375&nbsp;&mdash; 21 апреля того&nbsp;же года.</p>
<p>Зная даты первых покупок, можем строить когорты.</p>
<h2 id="Строим-когорты"><a href="#Строим-когорты" class="headerlink" title="Строим когорты"></a>Строим когорты</h2><p>Итак, когортами будем считать людей, сделавших первую покупку в&nbsp;тот или иной день. Метрики для отслеживания&nbsp;&mdash; количество заказов и&nbsp;выручка.</p>
<p>План такой: сначала добавим дату первой покупки пользователей в&nbsp;таблицу с&nbsp;заказами, затем сгруппируем по&nbsp;датам первой покупки и&nbsp;заказа и, наконец, посчитаем выручку и&nbsp;количество заказов каждой когорты.</p>
<p>Приступим. Добавим дату первой покупки с&nbsp;помощью метода <code>merge()</code> и&nbsp;сохраним получившийся датафрейм в&nbsp;переменную <code>orders_merged</code>:</p>
<script src="https://gist.github.com/kulichevskiy/a0a3ad5229ab82dfc7aa900fd52a1389.js"></script>

<p>В&nbsp;строках получившегося датафрейма всё еще покупки, но&nbsp;теперь в&nbsp;таблице появилась новая колонка: дата первой покупки пользователя.</p>
<p>Агрегируем по&nbsp;дате первой покупки и&nbsp;посчитаем нужные показатели:</p>
<script src="https://gist.github.com/kulichevskiy/a63ad68004c7181459117e10e7685a8c.js"></script>

<p>Видим, что клиенты от&nbsp;3 января 2014 года, всего сделали 9 заказов на&nbsp;$1050.6. Посмотрим, когда были эти заказы. Для этого добавим к&nbsp;группировке колонку <code>order_date</code>:</p>
<script src="https://gist.github.com/kulichevskiy/d6622170915e1c0bb3cf312ce3c33c90.js"></script>

<p>Ага, первый заказ этой когорты был 3 января на&nbsp;$16. В&nbsp;следующий раз клиент вернулся почти год спустя и&nbsp;купил что-то ещё, в&nbsp;этот раз на&nbsp;$153. Следующая покупка была уже в&nbsp;апреле 2015 и&nbsp;так далее.</p>
<p>Когорты готовы, теперь решим задачу.</p>
<h2 id="Решаем-задачу"><a href="#Решаем-задачу" class="headerlink" title="Решаем задачу"></a>Решаем задачу</h2><p>Напомню, что мы&nbsp;хотим посчитать, сколько в&nbsp;среднем заказов и&nbsp;выручки приносят клиенты в&nbsp;течение года, после первой покупки.</p>
<p>Мы&nbsp;знаем, сколько магазин заработал с&nbsp;каждой когорты за&nbsp;всё время. Уточним метрику: посчитаем показатели за&nbsp;первый год жизни когорты.</p>
<p>Сначала узнаем, сколько дней прошло между первой покупкой и&nbsp;последующим заказом, и&nbsp;удалим те, которые случились позже 365 дней. Чтобы посчитать количество дней между заказами, вычтем из&nbsp;колонки <code>order_date</code> столбец <code>first_order</code>:</p>
<script src="https://gist.github.com/kulichevskiy/8bbddaf50f03229dd679464096cc5222.js"></script>

<p>Вуаля. Видим, что, например, заказ <code>131884</code> случился 455 дней спустя первой покупки. <code>455 days</code>&nbsp;&mdash; это тип данных под названием &laquo;Timedelta&raquo;, его специально придумали, чтобы показывать временные промежутки.</p>
<p>Чтобы удалить поздние заказы, добавим условие <code>&lt;= &#39;365 days&#39;</code>:</p>
<script src="https://gist.github.com/kulichevskiy/8f6fab19b19d71618d3e0caecc62c0c7.js"></script>

<p>Сохраним результат в&nbsp;переменную <code>year_1_filter</code>, отфильтруем ненужные заказы из&nbsp;когортного отчета и&nbsp;сохраним результат в&nbsp;переменную <code>year_1_orders</code>:</p>
<script src="https://gist.github.com/kulichevskiy/254ca799d9002cef15f819c709a1b097.js"></script>

<p>В&nbsp;датафрейме остались только заказы, сделанные когортами в&nbsp;первый год после первой покупки. Теперь сгруппируем заказы по&nbsp;дате первой покупки и&nbsp;посчитаем нужные метрики. Результат сохраним в&nbsp;переменную <code>cohorts</code>:</p>
<script src="https://gist.github.com/kulichevskiy/5ddefa4d38848a2ac4d4066ffdcda393.js"></script>

<p>Последний шаг: посчитаем, сколько в&nbsp;среднем заказов и&nbsp;приносят клиенты в&nbsp;течение первого года. Для этого сначала просуммируем показатели каждой когорты, а&nbsp;затем усредним значения методом <code>mean()</code>:</p>
<script src="https://gist.github.com/kulichevskiy/adec10491e67999ff692f1ff2fe8ef6d.js"></script>

<p>Готово! В&nbsp;среднем за&nbsp;первый год когорты делают по&nbsp;4 заказа и&nbsp;приносят по&nbsp;$1949&nbsp;долларов.</p>
<p>Есть много способов улучшить решение, например сгруппировать дневные когорты в&nbsp;недельные или месячные, визуализировать отчет в&nbsp;таблице или на&nbsp;графике. Наконец, интересно разбить когорты по&nbsp;каким-то признакам, например, отделить частных покупателей от&nbsp;компаний&nbsp;&mdash; наверняка их&nbsp;показатели существенно отличаются.</p>
<p>Обо&nbsp;всем этом в&nbsp;следующих сериях. Подписывайтесь на&nbsp;<a target="_blank" rel="noopener" href="https://t.me/kulichevskiy">канал</a>, чтобы не&nbsp;пропустить. Ну&nbsp;и&nbsp;да, <a href="http://smysl.io/courses/data-1">приходите учиться на&nbsp;курс</a>!</p>
<p>Адиос!</p>
<p><em>Cпасибо Наташе Асаул за&nbsp;то, что помогла отредактировать статью.</em></p>
</div></div></div><div class="container container_margin"><div class="row"><div class="col-md-8 col-sm-12"><h1><a href="/blog/pandas/">Аналитикам: большая шпаргалка по Pandas</a></h1><blockquote>
<p>Привет. Я&nbsp;задумывал эту заметку для студентов курса <a target="_blank" rel="noopener" href="https://digitalgod.be/rockstar">Digital Rockstar</a>, на&nbsp;котором мы&nbsp;учим маркетологов автоматизировать свою работу с&nbsp;помощью программирования, но&nbsp;решил поделиться шпаргалкой по&nbsp;Pandas со&nbsp;всеми. Я&nbsp;ожидаю, что читатель умеет писать код на&nbsp;Python хотя&nbsp;бы на&nbsp;минимальном уровне, знает, что такое списки, словари, циклы и&nbsp;функции.</p>
</blockquote>
<ol>
<li><a href="#Что-такое-Pandas-и-зачем-он-нужен">Что такое Pandas и&nbsp;зачем он&nbsp;нужен</a></li>
<li><a href="#Структуры-данных">Структуры данных: серии и&nbsp;датафреймы</a></li>
<li><a href="#Создаем-датафреймы-и-загружаем-в-них-данные">Создаем датафреймы и&nbsp;загружаем в&nbsp;них данные</a></li>
<li><a href="#Исследуем-загруженные-данные">Исследуем загруженные данные</a></li>
<li><a href="#Получаем-данные-из-датафреймов">Получаем данные из&nbsp;датафреймов</a></li>
<li><a href="#Считаем-производные-метрики">Считаем производные метрики</a></li>
<li><a href="#Объединяем-несколько-датафреймов">Объединяем несколько датафреймов</a></li>
<li><a href="#Решаем-задачу">Решаем задачу</a></li>
</ol>
<h2 id="Что-такое-Pandas-и-nbsp-зачем-он-nbsp-нужен"><a href="#Что-такое-Pandas-и-nbsp-зачем-он-nbsp-нужен" class="headerlink" title="Что такое Pandas и&nbsp;зачем он&nbsp;нужен"></a>Что такое Pandas и&nbsp;зачем он&nbsp;нужен</h2><p>Pandas&nbsp;&mdash; это библиотека для работы с&nbsp;данными на&nbsp;Python. Она упрощает жизнь аналитикам: где раньше использовалось 10 строк кода теперь хватит одной.</p>
<p>Например, чтобы прочитать данные из&nbsp;csv, в&nbsp;стандартном Python надо сначала решить, как хранить данные, затем открыть файл, прочитать его построчно, отделить значения друг от&nbsp;друга и&nbsp;очистить данные от&nbsp;специальных символов.</p>
<pre><code>&gt; with open(&#39;file.csv&#39;) as f:
...    content &#x3D; f.readlines()
...    content &#x3D; [x.split(&#39;,&#39;).replace(&#39;\n&#39;,&#39;&#39;) for x in content]</code></pre>
<p>В&nbsp;Pandas всё проще. Во-первых, не&nbsp;нужно думать, как будут храниться данные&nbsp;&mdash; они лежат в&nbsp;датафрейме. Во-вторых, достаточно написать одну команду:</p>
<pre><code>&gt; data &#x3D; pd.read_csv(&#39;file.csv&#39;)</code></pre>
<p>Pandas добавляет в&nbsp;Python новые структуры данных&nbsp;&mdash; серии и&nbsp;датафреймы. Расскажу, что это такое.</p>
<h2 id="Структуры-данных-серии-и-nbsp-датафреймы"><a href="#Структуры-данных-серии-и-nbsp-датафреймы" class="headerlink" title="Структуры данных: серии и&nbsp;датафреймы"></a>Структуры данных: серии и&nbsp;датафреймы</h2><p>Серии&nbsp;&mdash; одномерные массивы данных. Они очень похожи на&nbsp;списки, но&nbsp;отличаются по&nbsp;поведению&nbsp;&mdash; например, операции применяются к&nbsp;списку целиком, а&nbsp;в&nbsp;сериях&nbsp;&mdash; поэлементно.</p>
<p>То&nbsp;есть, если список умножить на&nbsp;2, получите тот&nbsp;же список, повторенный 2 раза.</p>
<pre><code>&gt; vector &#x3D; [1, 2, 3]
&gt; vector * 2
[1, 2, 3, 1, 2, 3]</code></pre>
<p>А если умножить серию, ее длина не изменится, а вот элементы удвоятся.</p>
<pre><code>&gt; import pandas as pd
&gt; series &#x3D; pd.Series([1, 2, 3])
&gt; series * 2
0    2
1    4
2    6
dtype: int64</code></pre>
<p>Обратите внимание на&nbsp;первый столбик вывода. Это индекс, в&nbsp;котором хранятся адреса каждого элемента серии. Каждый элемент потом можно получать, обратившись по&nbsp;нужному адресу.</p>
<pre><code>&gt; series &#x3D; pd.Series([&#39;foo&#39;, &#39;bar&#39;])
&gt; series[0]
&#39;foo&#39;</code></pre>
<p>Еще одно отличие серий от&nbsp;списков&nbsp;&mdash; в&nbsp;качестве индексов можно использовать произвольные значения, это делает данные нагляднее. Представим, что мы&nbsp;анализируем помесячные продажи. Используем в&nbsp;качестве индексов названия месяцев, значениями будет выручка:</p>
<pre><code>&gt; months &#x3D; [&#39;jan&#39;, &#39;feb&#39;, &#39;mar&#39;, &#39;apr&#39;]
&gt; sales &#x3D; [100, 200, 300, 400]
&gt; data &#x3D; pd.Series(data&#x3D;sales, index&#x3D;months)
&gt; data
jan    100
feb    200
mar    300
apr    400
dtype: int64</code></pre>
<p>Теперь можем получать значения каждого месяца:</p>
<pre><code>&gt; data[&#39;feb&#39;]
200</code></pre>
<p>Так как серии&nbsp;&mdash; одномерный массив данных, в&nbsp;них удобно хранить измерения по&nbsp;одному. На&nbsp;практике удобнее группировать данные вместе. Например, если мы&nbsp;анализируем помесячные продажи, полезно видеть не&nbsp;только выручку, но&nbsp;и&nbsp;количество проданных товаров, количество новых клиентов и&nbsp;средний чек. Для этого отлично подходят датафреймы.</p>
<p>Датафреймы&nbsp;&mdash; это таблицы. У&nbsp;их&nbsp;есть строки, колонки и&nbsp;ячейки.</p>
<p>Технически, колонки датафреймов&nbsp;&mdash; это серии. Поскольку в&nbsp;колонках обычно описывают одни и&nbsp;те&nbsp;же объекты, то&nbsp;все колонки делят один и&nbsp;тот&nbsp;же индекс:</p>
<pre><code>&gt; months &#x3D; [&#39;jan&#39;, &#39;feb&#39;, &#39;mar&#39;, &#39;apr&#39;]
&gt; sales &#x3D; {
...    &#39;revenue&#39;:     [100, 200, 300, 400],
...    &#39;items_sold&#39;:  [23, 43, 55, 65],
...    &#39;new_clients&#39;: [10, 20, 30, 40]
...}
&gt; sales_df &#x3D; pd.DataFrame(data&#x3D;sales, index&#x3D;months)
&gt; sales_df
     revenue  items_sold  new_clients
jan      100          23           10
feb      200          43           20
mar      300          55           30
apr      400          65           40</code></pre>
<p>Объясню, как создавать датафреймы и&nbsp;загружать в&nbsp;них данные.</p>
<h2 id="Создаем-датафреймы-и-nbsp-загружаем-данные"><a href="#Создаем-датафреймы-и-nbsp-загружаем-данные" class="headerlink" title="Создаем датафреймы и&nbsp;загружаем данные"></a>Создаем датафреймы и&nbsp;загружаем данные</h2><p>Бывает, что мы&nbsp;не&nbsp;знаем, что собой представляют данные, и&nbsp;не&nbsp;можем задать структуру заранее. Тогда удобно создать пустой датафрейм и&nbsp;позже наполнить его данными.</p>
<pre><code>&gt; df &#x3D; pd.DataFrame()</code></pre>
<p>А&nbsp;иногда данные уже есть, но&nbsp;хранятся в&nbsp;переменной из&nbsp;стандартного Python, например, в&nbsp;словаре. Чтобы получить датафрейм, эту переменную передаем в&nbsp;ту&nbsp;же команду:</p>
<pre><code>&gt; df &#x3D; pd.DataFrame(data&#x3D;sales, index&#x3D;months))</code></pre>
<p>Случается, что в&nbsp;некоторых записях не&nbsp;хватает данных. Например, посмотрите на&nbsp;список <code>goods_sold</code>&nbsp;&mdash; в&nbsp;нём продажи, разбитые по&nbsp;товарным категориям. За&nbsp;первый месяц мы&nbsp;продали машины, компьютеры и&nbsp;программное обеспечение. Во&nbsp;втором машин нет, зато появились велосипеды, а&nbsp;в&nbsp;третьем снова появились машины, но&nbsp;велосипеды исчезли:</p>
<pre><code>&gt; goods_sold &#x3D; [
...     {&#39;computers&#39;: 10, &#39;cars&#39;: 1, &#39;soft&#39;: 3},
...     {&#39;computers&#39;: 4, &#39;soft&#39;: 5, &#39;bicycles&#39;: 1},
...     {&#39;computers&#39;: 6, &#39;cars&#39;: 2, &#39;soft&#39;: 3}
... ]</code></pre>
<p>Если загрузить данные в&nbsp;датафрейм, Pandas создаст колонки для всех товарных категорий и, где это возможно, заполнит их&nbsp;данными:</p>
<pre><code>&gt; pd.DataFrame(goods_sold)
   bicycles  cars  computers  soft
0       NaN   1.0         10     3
1       1.0   NaN          4     5
2       NaN   2.0          6     3</code></pre>
<p>Обратите внимание, продажи велосипедов в&nbsp;первом и&nbsp;третьем месяце равны <code>NaN</code>&nbsp;&mdash; расшифровывается как Not a&nbsp;Number. Так Pandas помечает отсутствующие значения.</p>
<p>Теперь разберем, как загружать данные из&nbsp;файлов. Чаще всего данные хранятся в&nbsp;экселевских таблицах или csv-, tsv- файлах.</p>
<p>Экселевские таблицы читаются с&nbsp;помощью команды <code>pd.read_excel()</code>. Параметрами нужно передать адрес файла на&nbsp;компьютере и&nbsp;название листа, который нужно прочитать. Команда работает как&nbsp;с&nbsp;xls, так и&nbsp;с&nbsp;xlsx:</p>
<pre><code>&gt; pd.read_excel(&#39;file.xlsx&#39;, sheet_name&#x3D;&#39;Sheet1&#39;)</code></pre>
<p>Файлы формата csv и&nbsp;tsv&nbsp;&mdash; это текстовые файлы, в&nbsp;которых данные отделены друг от&nbsp;друга запятыми или табуляцией:</p>
<pre><code># CSV
month,customers,sales
feb,10,200

# TSV
month\tcustomers\tsales
feb\t10\t200</code></pre>
<p>Оба читаются с&nbsp;помощью команды <code>.read_csv()</code>, символ табуляции передается параметром <code>sep</code> (от&nbsp;англ. <em>separator</em>&nbsp;&mdash; разделитель):</p>
<pre><code>&gt; pd.read_csv(&#39;file.csv&#39;)
&gt; pd.read_csv(&#39;file.tsv&#39;, sep&#x3D;&#39;\t&#39;)</code></pre>
<p>При загрузке можно назначить столбец, который будет индексом. Представьте, что мы&nbsp;загружаем таблицу с&nbsp;заказами. У&nbsp;каждого заказа есть свой уникальный номер, Если назначим этот номер индексом, сможем выгружать данные командой <code>df[order_id]</code>. Иначе придется писать фильтр <code>df[df[‘id’] == order_id ]</code>.</p>
<p>О&nbsp;том, как получать данные из&nbsp;датафреймов, я&nbsp;расскажу в&nbsp;одном из&nbsp;следующих разделов. Чтобы назначить колонку индексом, добавим в&nbsp;команду <code>read_csv()</code> параметр <code>index_col</code>, равный названию нужной колонки:</p>
<pre><code>&gt; pd.read_csv(&#39;file.csv&#39;, index_col&#x3D;&#39;id&#39;)</code></pre>
<p>После загрузки данных в&nbsp;датафрейм, хорошо&nbsp;бы их&nbsp;исследовать&nbsp;&mdash; особенно, если они вам незнакомы.</p>
<h2 id="Исследуем-загруженные-данные"><a href="#Исследуем-загруженные-данные" class="headerlink" title="Исследуем загруженные данные"></a>Исследуем загруженные данные</h2><p>Представим, что мы&nbsp;анализируем продажи американского интернет-магазина. У&nbsp;нас есть данные о&nbsp;заказах и&nbsp;клиентах. Загрузим файл с&nbsp;продажами интернет-магазина в&nbsp;переменную <code>orders</code>. Раз загружаем заказы, укажем, что колонка <code>id</code> пойдет в&nbsp;индекс:</p>
<pre><code>&gt; orders &#x3D; pd.read_csv(&#39;orders.csv&#39;, index_col&#x3D;&#39;id&#39;)</code></pre>
<p>Расскажу о&nbsp;четырех атрибутах, которые есть у&nbsp;любого датафрейма: <code>.shape</code>, <code>.columns</code>, <code>.index</code> и&nbsp;<code>.dtypes</code>.</p>
<p><code>.shape</code> показывает, сколько в&nbsp;датафрейме строк и&nbsp;колонок. Он&nbsp;возвращает пару значений <code>(n_rows, n_columns)</code>. Сначала идут строки, потом колонки.</p>
<pre><code>&gt; orders.shape
(5009, 5)</code></pre>
<p>В&nbsp;датафрейме 5009 строк и&nbsp;5 колонок.</p>
<p>Окей, масштаб оценили. Теперь посмотрим, какая информация содержится в&nbsp;каждой колонке. С&nbsp;помощью <code>.columns</code> узнаем названия колонок:</p>
<pre><code>&gt; orders.columns
Index([&#39;order_date&#39;, &#39;ship_mode&#39;, &#39;customer_id&#39;, &#39;sales&#39;], dtype&#x3D;&#39;object&#39;)</code></pre>
<p>Теперь видим, что в&nbsp;таблице есть дата заказа, метод доставки, номер клиента и&nbsp;выручка.</p>
<p>С&nbsp;помощью <code>.dtypes</code> узнаем типы данных, находящихся в&nbsp;каждой колонке и&nbsp;поймем, надо&nbsp;ли их&nbsp;обрабатывать. Бывает, что числа загружаются в&nbsp;виде текста. Если мы&nbsp;попробуем сложить две текстовых значения <code>&#39;1&#39; + &#39;1&#39;</code>, то&nbsp;получим не&nbsp;число 2, а&nbsp;строку <code>&#39;11&#39;</code>:</p>
<pre><code>&gt; orders.dtypes
order_date      object
ship_mode       object
customer_id     object
sales          float64
dtype: object</code></pre>
<p>Тип <code>object</code>&nbsp;&mdash; это текст, <code>float64</code>&nbsp;&mdash; это дробное число типа 3,14.</p>
<p>C&nbsp;помощью атрибута <code>.index</code> посмотрим, как называются строки:</p>
<pre><code>&gt; orders.index
Int64Index([100006, 100090, 100293, 100328, 100363, 100391, 100678, 100706,
            100762, 100860,
            ...
            167570, 167920, 168116, 168613, 168690, 168802, 169320, 169488,
            169502, 169551],
           dtype&#x3D;&#39;int64&#39;, name&#x3D;&#39;id&#39;, length&#x3D;5009)</code></pre>
<p>Ожидаемо, в&nbsp;индексе датафрейма номера заказов: 100762, 100860 и&nbsp;так далее.</p>
<p>В&nbsp;колонке <code>sales</code> хранится стоимость каждого проданного товара. Чтобы узнать разброс значений, среднюю стоимость и&nbsp;медиану, используем метод <code>.describe()</code>:</p>
<pre><code>&gt; orders.describe()
         sales
count   5009.0
mean     458.6
std      954.7
min        0.6
25%       37.6
50%      152.0
75%      512.1
max    23661.2</code></pre>
<p>Наконец, чтобы посмотреть на&nbsp;несколько примеров записей датафрейма, используем команды <code>.head()</code> и&nbsp;<code>.sample()</code>. Первая возвращает 6 записей из&nbsp;начала датафрейма. Вторая&nbsp;&mdash; 6 случайных записей:</p>
<pre><code>&gt; orders.head()
        order_date ship_mode customer_id    sales
id                                                                         
100006  2014-09-07  Standard    DK-13375  377.970
100090  2014-07-08  Standard    EB-13705  699.192
100293  2014-03-14  Standard    NF-18475   91.056
100328  2014-01-28  Standard    JC-15340    3.928
100363  2014-04-08  Standard    JM-15655   21.376</code></pre>
<p>Получив первое представление о&nbsp;датафреймах, теперь обсудим, как доставать из&nbsp;него данные.</p>
<h2 id="Получаем-данные-из-nbsp-датафреймов"><a href="#Получаем-данные-из-nbsp-датафреймов" class="headerlink" title="Получаем данные из&nbsp;датафреймов"></a>Получаем данные из&nbsp;датафреймов</h2><p>Данные из&nbsp;датафреймов можно получать по-разному: указав номера колонок и&nbsp;строк, использовав условные операторы или язык запросов. Расскажу подробнее о&nbsp;каждом способе.</p>
<h3 id="Указываем-нужные-строки-и-nbsp-колонки"><a href="#Указываем-нужные-строки-и-nbsp-колонки" class="headerlink" title="Указываем нужные строки и&nbsp;колонки"></a>Указываем нужные строки и&nbsp;колонки</h3><p>Продолжаем анализировать продажи интернет-магазина, которые загрузили в&nbsp;предыдущем разделе. Допустим, я&nbsp;хочу вывести столбец <code>sales</code>. Для этого название столбца нужно заключить в&nbsp;квадратные скобки и&nbsp;поставить после них названия датафрейма: <code>orders[&#39;sales&#39;]</code>:</p>
<pre><code>&gt; orders[&#39;sales&#39;]
id
100006     377.970
100090     699.192
100293      91.056
100328       3.928
100363      21.376
100391      14.620
100678     697.074
100706     129.440
...</code></pre>
<p>Обратите внимание, результат команды&nbsp;&mdash; новый датафрейм с&nbsp;таким&nbsp;же индексом.</p>
<p>Если нужно вывести несколько столбцов, в&nbsp;квадратные скобки нужно вставить список с&nbsp;их&nbsp;названиями: <code>orders[[&#39;customer_id&#39;, &#39;sales&#39;]]</code>. Будьте внимательны: квадратные скобки стали двойными. Первые&nbsp;&mdash; от&nbsp;датафрейма, вторые&nbsp;&mdash; от&nbsp;списка:</p>
<pre><code>&gt; orders[[&#39;customer_id&#39;, &#39;sales&#39;]]
       customer_id     sales
id                                  
100006    DK-13375   377.970
100090    EB-13705   699.192
100293    NF-18475    91.056
100328    JC-15340     3.928
100363    JM-15655    21.376
100391    BW-11065    14.620
100363    KM-16720   697.074
100706    LE-16810   129.440
...</code></pre>
<p>Перейдем к&nbsp;строкам. Их&nbsp;можно фильтровать по&nbsp;индексу и&nbsp;по&nbsp;порядку. Например, мы&nbsp;хотим вывести только заказы 100363, 100391 и&nbsp;100706, для этого есть команда <code>.loc[]</code>:</p>
<pre><code>&gt; show_these_orders &#x3D; [&#39;100363&#39;, &#39;100363&#39;, &#39;100706&#39;]
&gt; orders.loc[show_these_orders]
        order_date ship_mode customer_id    sales
id                                                             
100363  2014-04-08  Standard    JM-15655   21.376
100363  2014-04-08  Standard    JM-15655   21.376
100706  2014-12-16    Second    LE-16810  129.440</code></pre>
<p>А в другой раз бывает нужно достать просто заказы с 1 по 3 по порядку, вне зависимости от их номеров в таблицемы. Тогда используют команду <code>.iloc[]</code>:</p>
<pre><code>&gt; show_these_orders &#x3D; [1, 2, 3]
&gt; orders.iloc[show_these_orders]
        order_date ship_mode customer_id    sales
id                                                             
100090  2014-04-08  Standard    JM-15655   21.376
100293  2014-04-08  Standard    JM-15655   21.376
100328  2014-12-16    Second    LE-16810  129.440</code></pre>
<p>Можно фильтровать датафреймы по&nbsp;колонкам и&nbsp;столбцам одновременно:</p>
<pre><code>&gt; columns &#x3D; [&#39;customer_id&#39;, &#39;sales&#39;]
&gt; rows &#x3D; [&#39;100363&#39;, &#39;100363&#39;, &#39;100706&#39;]
&gt; orders.loc[rows][columns]
       customer_id    sales
id                                 
100363    JM-15655   21.376
100363    JM-15655   21.376
100706    LE-16810  129.440
...</code></pre>
<p>Часто вы&nbsp;не&nbsp;знаете заранее номеров заказов, которые вам нужны. Например, если задача&nbsp;&mdash; получить заказы, стоимостью более 1000&nbsp;рублей. Эту задачу удобно решать с&nbsp;помощью условных операторов.</p>
<h3 id="Если-nbsp-mdash-то-Условные-операторы"><a href="#Если-nbsp-mdash-то-Условные-операторы" class="headerlink" title="Если&nbsp;&mdash; то. Условные операторы"></a>Если&nbsp;&mdash; то. Условные операторы</h3><p>Задача: нужно узнать, откуда приходят самые большие заказы. Начнем с&nbsp;того, что достанем все покупки стоимостью более 1000&nbsp;долларов:</p>
<pre><code>&gt; filter_large &#x3D; orders[&#39;sales&#39;] &gt; 1000
&gt; orders.loc[filter_slarge]
        order_date ship_mode customer_id     sales
id                                                             
101931  2014-10-28     First    TS-21370  1252.602
102673  2014-11-01  Standard    KH-16630  1044.440
102988  2014-04-05    Second    GM-14695  4251.920
103100  2014-12-20     First    AB-10105  1107.660
103310  2014-05-10  Standard    GM-14680  1769.784
...</code></pre>
<p>Помните, в&nbsp;начале статьи я&nbsp;упоминал, что в&nbsp;сериях все операции применяются по-элементно? Так вот, операция <code>orders[&#39;sales&#39;] &gt; 1000</code> идет по&nbsp;каждому элементу серии и, если условие выполняется, возвращает <code>True</code>. Если не&nbsp;выполняется&nbsp;&mdash; <code>False</code>. Получившуюся серию мы&nbsp;сохраняем в&nbsp;переменную <code>filter_large</code>.</p>
<p>Вторая команда фильтрует строки датафрейма с&nbsp;помощью серии. Если элемент <code>filter_large</code> равен <code>True</code>, заказ отобразится, если <code>False</code>&nbsp;&mdash; нет. Результат&nbsp;&mdash; датафрейм с&nbsp;заказами, стоимостью более 1000&nbsp;долларов.</p>
<p>Интересно, сколько дорогих заказов было доставлено первым классом? Добавим в&nbsp;фильтр ещё одно условие:</p>
<pre><code>&gt; filter_large &#x3D; df[&#39;sales&#39;] &gt; 1000
&gt; filter_first_class &#x3D; orders[&#39;ship_mode&#39;] &#x3D;&#x3D; &#39;First&#39;
&gt; orders.loc[filter_large &amp; filter_first_class]
        order_date ship_mode customer_id     sales
id                                                           
101931  2014-10-28     First    TS-21370  1252.602
103100  2014-12-20     First    AB-10105  1107.660
106726  2014-12-06     First    RS-19765  1261.330
112158  2014-12-02     First    DP-13165  1050.600
116666  2014-05-08     First    KT-16480  1799.970
...</code></pre>
<p>Логика не&nbsp;изменилась. В&nbsp;переменную <code>filter_large</code> сохранили серию, удовлетворяющую условию <code>orders[&#39;sales&#39;] &gt; 1000</code>. В&nbsp;<code>filter_first_class</code>&nbsp;&mdash; серию, удовлетворяющую <code>orders[&#39;ship_mode&#39;] == &#39;First&#39;</code>.</p>
<p>Затем объединили обе серии с&nbsp;помощью логического ‘И’: <code>filter_first_class &amp; filter_first_class</code>. Получили новую серию той&nbsp;же длины, в&nbsp;элементах которой <code>True</code> только у&nbsp;заказов, стоимостью больше 1000, доставленных первым классом. Таких условий может быть сколько угодно.</p>
<h3 id="Язык-запросов"><a href="#Язык-запросов" class="headerlink" title="Язык запросов"></a>Язык запросов</h3><p>Еще один способ решить предыдущую задачу&nbsp;&mdash; использовать язык запросов. Все условия пишем одной строкой <code>&#39;sales &gt; 1000 &amp; ship_mode == &#39;First&#39;</code> и&nbsp;передаем ее&nbsp;в&nbsp;метод <code>.query()</code>. Запрос получается компактнее.</p>
<pre><code>&gt; orders.query(&#39;sales &gt; 1000 &amp; ship_mode &#x3D;&#x3D; First&#39;)
        order_date ship_mode customer_id     sales
id                                                           
101931  2014-10-28     First    TS-21370  1252.602
103100  2014-12-20     First    AB-10105  1107.660
106726  2014-12-06     First    RS-19765  1261.330
112158  2014-12-02     First    DP-13165  1050.600
116666  2014-05-08     First    KT-16480  1799.970
...</code></pre>
<p>Отдельный кайф: значения для фильтров можно сохранить в&nbsp;переменной, а&nbsp;в&nbsp;запросе сослаться на&nbsp;нее с&nbsp;помощью символа @: <code>sales &gt; @sales_filter</code>.</p>
<pre><code>&gt; sales_filter &#x3D; 1000
&gt; ship_mode_filter &#x3D; &#39;First&#39;
&gt; orders.query(&#39;sales &gt; @sales_filter &amp; ship_mode &gt; @ship_mode_filter&#39;)
         order_date ship_mode customer_id     sales
id                                                           
101931  2014-10-28     First    TS-21370  1252.602
103100  2014-12-20     First    AB-10105  1107.660
106726  2014-12-06     First    RS-19765  1261.330
112158  2014-12-02     First    DP-13165  1050.600
116666  2014-05-08     First    KT-16480  1799.970
...</code></pre>
<p>Разобравшись, как получать куски данных из&nbsp;датафрейма, перейдем к&nbsp;тому, как считать агрегированные метрики: количество заказов, суммарную выручку, средний чек, конверсию.</p>
<h2 id="Считаем-производные-метрики"><a href="#Считаем-производные-метрики" class="headerlink" title="Считаем производные метрики"></a>Считаем производные метрики</h2><p>Задача: посчитаем, сколько денег магазин заработал с&nbsp;помощью каждого класса доставки. Начнем с&nbsp;простого&nbsp;&mdash; просуммируем выручку со&nbsp;всех заказов. Для этого используем метод <code>.sum()</code>:</p>
<pre><code>&gt; orders[&#39;sales&#39;].sum()
2297200.8603000003</code></pre>
<p>Добавим класс доставки. Перед суммированием сгруппируем данные с&nbsp;помощью метода <code>.groupby()</code>:</p>
<pre><code>&gt; orders.groupby(&#39;ship_mode&#39;)[&#39;sales&#39;].sum()
ship_mode              
First      3.514284e+05
Same Day   1.283631e+05
Second     4.591936e+05
Standard   1.358216e+06</code></pre>
<p><code>3.514284e+05</code>&nbsp;&mdash; научный формат вывода чисел. Означает 3.51 * 10<sup>5</sup>. Нам такая точность не&nbsp;нужна, поэтому можем сказать Pandas, чтобы округлял значения до&nbsp;сотых:</p>
<pre><code>&gt; pd.options.display.float_format &#x3D; &#39;{:,.1f}&#39;.format
&gt; orders.groupby(&#39;ship_mode&#39;)[&#39;sales&#39;].sum()
ship_mode            
First       351,428.4
Same Day    128,363.1
Second      459,193.6
Standard  1,358,215.7</code></pre>
<p>Другое дело. Теперь видим сумму выручки по&nbsp;каждому классу доставки. По&nbsp;суммарной выручке неясно, становится лучше или хуже. Добавим разбивку по&nbsp;датам заказа:</p>
<pre><code>&gt; orders.groupby([&#39;ship_mode&#39;, &#39;order_date&#39;])[&#39;sales&#39;].sum()
ship_mode order_date        
First     2014-01-06    12.8
          2014-01-11     9.9
          2014-01-14    62.0
          2014-01-15   149.9
          2014-01-19   378.6
          2014-01-26   152.6
...</code></pre>
<p>Видно, что выручка прыгает ото дня ко&nbsp;дню: иногда 10&nbsp;долларов, а&nbsp;иногда 378. Интересно, это меняется количество заказов или средний чек? Добавим к&nbsp;выборке количество заказов. Для этого вместо <code>.sum()</code> используем метод <code>.agg()</code>, в&nbsp;который передадим список с&nbsp;названиями нужных функций.</p>
<pre><code>&gt; orders.groupby([&#39;ship_mode&#39;, &#39;order_date&#39;])[&#39;sales&#39;].agg([&#39;sum&#39;, &#39;count&#39;])
                       sum  count
ship_mode order_date             
First     2014-01-06  12.8      1
          2014-01-11   9.9      1
          2014-01-14  62.0      1
          2014-01-15 149.9      1
          2014-01-19 378.6      1
          2014-01-26 152.6      1
...</code></pre>
<p>Ого, получается, что это так прыгает средний чек. Интересно, а&nbsp;какой был самый удачный день? Чтобы узнать, отсортируем получившийся датафрейм: выведем 10 самых денежных дней по&nbsp;выручке:</p>
<pre><code>&gt; orders.groupby([&#39;ship_mode&#39;, &#39;order_date&#39;])[&#39;sales&#39;].agg([&#39;sum&#39;]).sort_values(by&#x3D;&#39;sum&#39;, ascending&#x3D;False).head(10)
                          sum
ship_mode order_date         
Standard  2014-03-18 26,908.4
          2016-10-02 18,398.2
First     2017-03-23 14,299.1
Standard  2014-09-08 14,060.4
First     2017-10-22 13,716.5
Standard  2016-12-17 12,185.1
          2017-11-17 12,112.5
          2015-09-17 11,467.6
          2016-05-23 10,561.0
          2014-09-23 10,478.6
</code></pre>
<p>Команда разрослась, и&nbsp;её теперь неудобно читать. Чтобы упростить, можно разбить её на&nbsp;несколько строк. В&nbsp;конце каждой строки ставим обратный слеш <code>\</code>:</p>
<pre><code>&gt; orders \
... .groupby([&#39;ship_mode&#39;, &#39;order_date&#39;])[&#39;sales&#39;] \
... .agg([&#39;sum&#39;]) \
... .sort_values(by&#x3D;&#39;sum&#39;, ascending&#x3D;False) \
... .head(10)
                          sum
ship_mode order_date         
Standard  2014-03-18 26,908.4
          2016-10-02 18,398.2
First     2017-03-23 14,299.1
Standard  2014-09-08 14,060.4
First     2017-10-22 13,716.5
Standard  2016-12-17 12,185.1
          2017-11-17 12,112.5
          2015-09-17 11,467.6
          2016-05-23 10,561.0
          2014-09-23 10,478.6
</code></pre>
<p>В самый удачный день&nbsp;&mdash; 18&nbsp;марта 2014 года&nbsp;&mdash; магазин заработал 27 тысяч долларов с&nbsp;помощью стандартного класса доставки. Интересно, откуда были клиенты, сделавшие эти заказы? Чтобы узнать, надо объединить данные о&nbsp;заказах с&nbsp;данными о&nbsp;клиентах.</p>
<h2 id="Объединяем-несколько-датафреймов"><a href="#Объединяем-несколько-датафреймов" class="headerlink" title="Объединяем несколько датафреймов"></a>Объединяем несколько датафреймов</h2><p>До&nbsp;сих пор мы&nbsp;смотрели только на&nbsp;таблицу с&nbsp;заказами. Но&nbsp;ведь у&nbsp;нас есть еще данные о&nbsp;клиентах интернет-магазина. Загрузим их&nbsp;в&nbsp;переменную <code>customers</code> и&nbsp;посмотрим, что они собой представляют:</p>
<pre><code>&gt; customers &#x3D; pd.read_csv(&#39;customers.csv&#39;, index&#x3D;&#39;id&#39;)
&gt; customers.head()
                     name    segment           state             city
id                                                                   
CG-12520      Claire Gute   Consumer        Kentucky        Henderson
DV-13045  Darrin Van Huff  Corporate      California      Los Angeles
SO-20335   Sean O&#39;Donnell   Consumer         Florida  Fort Lauderdale
BH-11710  Brosina Hoffman   Consumer      California      Los Angeles
AA-10480     Andrew Allen   Consumer  North Carolina          Concord</code></pre>
<p>Мы&nbsp;знаем тип клиента, место его проживания, его имя и&nbsp;имя контактного лица. У&nbsp;каждого клиента есть уникальный номер <code>id</code>. Этот&nbsp;же номер лежит в&nbsp;колонке <code>customer_id</code> таблицы <code>orders</code>. Значит мы&nbsp;можем найти, какие заказы сделал каждый клиент. Например, посмотрим, заказы пользователя <code>CG-12520</code>:</p>
<pre><code>&gt; cust_filter &#x3D; &#39;CG-12520&#39;
&gt; orders.query(&#39;customer_id &#x3D;&#x3D; @cust_filter&#39;)
                order_date ship_mode customer_id   sales
id                                                          
CA-2016-152156  2016-11-08    Second    CG-12520  993.90
CA-2017-164098  2017-01-26     First    CG-12520   18.16
US-2015-123918  2015-10-15  Same Day    CG-12520  136.72</code></pre>
<p>Вернемся к&nbsp;задаче из&nbsp;предыдущего раздела: узнать, что за&nbsp;клиенты, которые сделали 18&nbsp;марта заказы со&nbsp;стандартной доставкой. Для этого объединим таблицы с&nbsp;клиентами и&nbsp;заказами. Датафреймы объединяют с&nbsp;помощью методов <code>.concat()</code>, <code>.merge()</code> и&nbsp;<code>.join()</code>. Все они делают одно и&nbsp;то&nbsp;же, но&nbsp;отличаются синтаксисом&nbsp;&mdash; на&nbsp;практике достаточно уметь пользоваться одним из&nbsp;них.</p>
<p>Покажу на&nbsp;примере <code>.merge()</code>:</p>
<pre><code>&gt; new_df &#x3D; pd.merge(orders, customers, how&#x3D;&#39;inner&#39;, left_on&#x3D;&#39;customer_id&#39;, right_index&#x3D;True)
&gt; new_df.columns
Index([&#39;order_date&#39;, &#39;ship_mode&#39;, &#39;customer_id&#39;, &#39;sales&#39;, &#39;name&#39;, &#39;segment&#39;,
       &#39;state&#39;, &#39;city&#39;],
      dtype&#x3D;&#39;object&#39;)</code></pre>
<p>В&nbsp;<code>.merge()</code> я&nbsp;сначала указал названия датафреймов, которые хочу объединить. Затем уточнил, как именно их&nbsp;объединить и&nbsp;какие колонки использовать в&nbsp;качестве ключа.</p>
<p>Ключ&nbsp;&mdash; это колонка, связывающая оба датафрейма. В&nbsp;нашем случае&nbsp;&mdash; номер клиента. В&nbsp;таблице с&nbsp;заказами он&nbsp;в&nbsp;колонке <code>customer_id</code>, а&nbsp;таблице с&nbsp;клиентами&nbsp;&mdash; в&nbsp;индексе. Поэтому в&nbsp;команде мы&nbsp;пишем: <code>left_on=&#39;customer_id&#39;, right_index=True</code>.</p>
<h2 id="Решаем-задачу"><a href="#Решаем-задачу" class="headerlink" title="Решаем задачу"></a>Решаем задачу</h2><p>Закрепим полученный материал, решив задачу. Найдем 5 городов, принесших самую большую выручку в&nbsp;2016 году.</p>
<p>Для начала отфильтруем заказы из&nbsp;2016 года:</p>
<pre><code>&gt; orders_2016 &#x3D; orders.query(&quot;order_date &gt;&#x3D; &#39;2016-01-01&#39; &amp; order_date &lt;&#x3D; &#39;2016-12-31&#39;&quot;)
&gt; orders_2016.head()
       order_date ship_mode customer_id   sales
id                                             
100041 2016-11-20  Standard    BF-10975   328.5
100083 2016-11-24  Standard    CD-11980    24.8
100153 2016-12-13  Standard    KH-16630    63.9
100244 2016-09-20  Standard    GM-14695   475.7
100300 2016-06-24    Second    MJ-17740 4,823.1</code></pre>
<p>Город&nbsp;&mdash; это атрибут пользователей, а&nbsp;не&nbsp;заказов. Добавим информацию о&nbsp;пользователях:</p>
<pre><code>&gt; with_customers_2016 &#x3D; pd.merge(customers, orders_2016, how&#x3D;&#39;inner&#39;, left_index&#x3D;True, right_on&#x3D;&#39;customer_id&#39;)</code></pre>
<p>Cруппируем получившийся датафрейм по&nbsp;городам и&nbsp;посчитаем выручку:</p>
<pre><code>&gt; grouped_2016 &#x3D; with_customers_2016.groupby(&#39;city&#39;)[&#39;sales&#39;].sum()
&gt; grouped_2016.head()
city
Akron               1,763.0
Albuquerque           692.9
Amarillo              197.2
Arlington           5,672.1
Arlington Heights      14.1
Name: sales, dtype: float64</code></pre>
<p>Отсортируем по&nbsp;убыванию продаж и&nbsp;оставим топ-5:</p>
<pre><code>&gt; top5 &#x3D; grouped_2016.sort_values(ascending&#x3D;False).head(5)
&gt; print(top5)
city
New York City   53,094.1
Philadelphia    39,895.5
Seattle         33,955.5
Los Angeles     33,611.1
San Francisco   27,990.0
Name: sales, dtype: float64</code></pre>
<p>Готово!</p>
<p>Попробуйте сами:</p>
<p>Возьмите данные о&nbsp;<a href="http://smysl.io/data/pandas/orders.csv">заказах</a> и&nbsp;<a href="http://smysl.io/data/pandas/customers.csv">покупателях</a> и&nbsp;посчитайте:</p>
<ol>
<li>Сколько заказов, отправлено первым классом за&nbsp;последние 5 лет?</li>
<li>Сколько в&nbsp;базе клиентов из&nbsp;Калифорнии?</li>
<li>Сколько заказов они сделали?</li>
<li>Постройте сводную таблицу средних чеков по&nbsp;всем штатам за&nbsp;каждый год.</li>
</ol>
<p>Через некоторое время выложу ответы <a target="_blank" rel="noopener" href="https://t.me/kulichevskiy">в&nbsp;Телеграме</a>. Подписывайтесь, чтобы не&nbsp;пропустить ответы и&nbsp;новые статьи.</p>
<p>До&nbsp;скорого!</p>
<p><em>Кстати, большое спасибо Александру Марфицину за&nbsp;то, что помог отредактировать статью.</em></p>
</div></div></div><div class="container container_margin"><div class="row"><div class="col-md-8 col-sm-12"><h1><a href="/blog/sql-views/">Упрощаем вложенные SQL-запросы с помощью представлений</a></h1><blockquote>
<p>Заметка для читателей <a href="http://smysl.io/?utm_source=blog&amp;utm_medium=content&amp;utm_campaign=sql-views">онлайн-курса по&nbsp;аналитике</a></a>, которые прошли хотя&nbsp;бы 5 уроков, уже знают, что такое SQL и&nbsp;умеют писать запросы к&nbsp;базе. Если SQL для вас в&nbsp;новинку, почитайте <a target="_blank" rel="noopener" href="http://us2.campaign-archive2.com/?u=c36236612d4e515a821a0b7d9&amp;id=994ac3e2bf&amp;utm_source=facebook.com&amp;utm_medium=social&amp;utm_campaign=paru-mesyatsev-nazad-vc.ru-opublikoval-odi">вводный урок про базы данных</a>.</p>
</blockquote>
<p>Результат любого SQL-запроса&nbsp;&mdash; это таблица. Значит, к&nbsp;ней можно направлять новые запросы, её можно джоинить с&nbsp;другими таблицами и&nbsp;использовать в&nbsp;фильтрах. Это позволяет реализовывать сложную логику.</p>
<p>Например, в&nbsp;седьмом уроке я&nbsp;рассказываю, как с&nbsp;помощью SQL достать данные для когортного анализа.</p>
<p>Начинаем с&nbsp;безобидного &laquo;давайте подсчитаем, сколько людей в&nbsp;каждой когорте&raquo;:</p>
<pre><code>SELECT
  reg_month AS cohort_id,
  count(*)  AS cohort_size
FROM
  users
GROUP BY 1</code></pre>
<p>Потом считаем, сколько денег принесла каждая когорта:</p>
<pre><code>SELECT
  users.reg_month AS cohort_id,
  orders.month AS month,
  sum(orders.sum) AS cohort_revenue
FROM
  users INNER JOIN orders
  ON users.uid &#x3D; orders.uid
GROUP BY 1, 2</code></pre>
<p>Потом объединяем эти запросы, группируем и получаем вот такого монстра:</p>
<pre><code>SELECT
  rev.cohort_id AS cohort_id,
  rev.month AS month,
  rev.month - rev.cohort_id AS cohort_age,
  rev.cohort_revenue  &#x2F; size.cohort_size AS LTV,
  rev.cohort_revenue &#x2F; size.costs * 100 AS ROI
FROM
(
  SELECT
    reg_month AS cohort_id,
    count(*) AS cohort_size
  FROM
    users
  GROUP BY 1
  ) AS size
  INNER JOIN
(
  SELECT
    users.reg_month AS cohort_id,
    orders.month AS month,
    sum(orders.sum) AS cohort_revenue
  FROM
    users INNER JOIN orders
    ON users.uid &#x3D; orders.uid
    GROUP BY 1, 2
) AS rev
ON size.cohort_id &#x3D; rev.cohort_id</code></pre>
<p>Запрос правильный, но слишком громоздкий. Исправлять ошибки и вносить в&nbsp;него изменения — особый тип пытки.</p>
<p>Код можно упростить, если сохранить промежуточные результаты в виде представлений.</p>
<h2 id="Что-такое-представления-и-nbsp-как-они-работают"><a href="#Что-такое-представления-и-nbsp-как-они-работают" class="headerlink" title="Что такое представления и&nbsp;как они работают"></a>Что такое представления и&nbsp;как они работают</h2><p>Представления (ещё их называют «вью» от английского view) — это&nbsp;сохранённые запросы.</p>
<p>Внешне представление выглядит как ещё одна таблица. Если его использовать в&nbsp;запросе, база найдёт и&nbsp;подставит сохранённый код.</p>
<p>Например, мы сохранили запрос <code>SELECT * FROM some_table</code> в&nbsp;представление <code>my_view</code>. Теперь <code>my_view</code> можно использовать в&nbsp;запросах:</p>
<pre><code>SELECT …
FROM my_view
WHERE …</code></pre>
<p>Отправляем запрос — база находит и подставляет сохранённый код:</p>
<pre><code>SELECT …
FROM (SELECT * FROM some_table)
WHERE …</code></pre>
<p>Получаем результат, как при использовании вложенного селекта, но но более аккуратным кодом.</p>
<h2 id="Как-создать-представления"><a href="#Как-создать-представления" class="headerlink" title="Как создать представления"></a>Как создать представления</h2><p>В Бигквери нужно сначала выполнить запрос, затем нажать на кнопку Save View и выбрать название.</p>
<p>В других системах кнопки нет, но зато есть специальный запрос CREATE VIEW.</p>
<pre><code>CREATE VIEW my_view AS
  SELECT * FROM some_table</code></pre>
<p>Покажу подробней, как это работает в Бигквери, упрощу огромный запрос из начала статьи.</p>
<p>Сохраню первый запрос в представлении <code>cohort_sizes</code>:</p>
<img src="/img/sql-views/views1.gif" class="border-grey blog-content" title="width&#x3D;600">
<p>Теперь могу просто запрашивать SELECT * FROM cohort_size, добавлять фильтры, группировки и сортировки.</p>
<img src="/img/sql-views/views2.gif" class="border-grey blog-content" title="width&#x3D;600">
<p>Повторю процесс для второго запроса: отправлю, получу результат, сохраню представление <code>cohorts</code>.</p>
<img src="/img/sql-views/views3.gif" class="border-grey blog-content" title="width&#x3D;600">
<p>Теперь заменю вложенные селекты в большом запросе на созданные представления. Смотрите, насколько аккуратней стал запрос:</p>
<p><strong>Было:</strong></p>
<pre><code>SELECT
  rev.cohort_id AS cohort_id,
  rev.month AS month,
  rev.month - rev.cohort_id AS cohort_age,
  rev.cohort_revenue  &#x2F; size.cohort_size AS LTV,
  rev.cohort_revenue &#x2F; size.costs * 100 AS ROI
FROM
(
SELECT
  reg_month AS cohort_id,
  count(*) AS cohort_size
FROM
  users
GROUP BY 1
) AS size
INNER JOIN
(
SELECT
  users.reg_month AS cohort_id,
  orders.month AS month,
  sum(orders.sum) AS cohort_revenue
FROM
  users INNER JOIN orders
  ON users.uid &#x3D; orders.uid
  GROUP BY 1, 2
) AS rev
ON size.cohort_id &#x3D; rev.cohort_id</code></pre>
<p><strong>Стало:</strong></p>
<pre><code>SELECT
  rev.cohort_id AS cohort_id,
  rev.month AS month,
  rev.month - rev.cohort_id AS cohort_age,
  rev.cohort_revenue  &#x2F; size.cohort_size AS LTV,
  rev.cohort_revenue &#x2F; size.costs * 100 AS ROI
FROM
  cohort_sizes AS size
INNER JOIN
  cohorts AS rev
ON size.cohort_id &#x3D; rev.cohort_id</code></pre>
<p>На этом всё. Успехов.</p>
</div></div></div></div><footer id="bottom-outer" role="footer"><div id="bottom-inner"><div class="container"><div class="row"><div class="col-md-8 col-sm-12"><p><span>&copy; Алексей Куличевский 2017–2021</span></p></div></div></div></div></footer></div></div></div></div><script src="/lib/jquery-3.2.1.min.js"></script><script src="/js/glow.js"></script><script src="/js/app.js"></script><script src="/js/payment-form.js"> </script></body>