<!DOCTYPE html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta property="og:image" content="http://smysl.io/img/og.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Anonymous+Pro|PT+Mono"><link rel="stylesheet" href="/fonts/font-awesome-4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="/css/glow.css"><link rel="stylesheet" href="/css/lessons-pointer.css"><link rel="stylesheet" href="/css/social-likes_birman.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/landing.css"><link rel="stylesheet" href="/css/blog.css"><link rel="apple-touch-icon-precomposed" sizes="57x57" href="img/favicons/apple-touch-icon-57x57.png"><link rel="apple-touch-icon-precomposed" sizes="114x114" href="img/favicons/apple-touch-icon-114x114.png"><link rel="apple-touch-icon-precomposed" sizes="72x72" href="img/favicons/apple-touch-icon-72x72.png"><link rel="apple-touch-icon-precomposed" sizes="144x144" href="img/favicons/apple-touch-icon-144x144.png"><link rel="apple-touch-icon-precomposed" sizes="60x60" href="img/favicons/apple-touch-icon-60x60.png"><link rel="apple-touch-icon-precomposed" sizes="120x120" href="img/favicons/apple-touch-icon-120x120.png"><link rel="apple-touch-icon-precomposed" sizes="76x76" href="img/favicons/apple-touch-icon-76x76.png"><link rel="apple-touch-icon-precomposed" sizes="152x152" href="img/favicons/apple-touch-icon-152x152.png"><link rel="icon" type="image/png" href="img/favicons/favicon-196x196.png" sizes="196x196"><link rel="icon" type="image/png" href="img/favicons/favicon-96x96.png" sizes="96x96"><link rel="icon" type="image/png" href="img/favicons/favicon-32x32.png" sizes="32x32"><link rel="icon" type="image/png" href="img/favicons/favicon-16x16.png" sizes="16x16"><link rel="icon" type="image/png" href="img/favicons/favicon-128.png" sizes="128x128"><meta name="application-name" content=" "><meta name="msapplication-TileColor" content="#FFFFFF"><meta name="msapplication-TileImage" content="img/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="mg/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="img/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="img/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="img/favicons/mstile-310x310.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="jS-UOFLu8isjqw3UjLkGEP-fD-tG7w7cAMLIeSepC7M"><meta name="yandex-verification" content="3365363b8d7940a9"><link rel="icon" href="http://ono38scfe.bkt.clouddn.com/favicon_tree.ico"><link rel="icon" type="image/png" sizes="16x16" href="undefined"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-MS47VNR');</script><title>Алексей Куличевский, аналитик</title></head><body><!-- - Google Tag Manager (noscript)--><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-MS47VNR" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><!-- - End Google Tag Manager (noscript)--><div class="container"><div id="content-outer"><div id="content-inner"><div class="blog"><div class="container"><div class="row"><div class="col-md-8 col-sm-12"><div class="avatar"><span><img src="https://s.gravatar.com/avatar/e574dc154e694d72dc40e1dc9be17c32?s=80" width="40px" height="40px"></span><span class="author_name">Алексей Куличевский            <span style="font-family: graphik-regular;">Блог · <a class="header" href="https://t.me/kulichevskiy" target="_blank">Телеграм</a> · <a class="header" href="/courses/data-1">Курс</a></span></span></div></div></div></div><div id="recent-posts"><div class="container container_margin"><div class="row"><div class="col-md-8 col-sm-12"><h1><a href="/blog/pandas-cohorts/">Когортный анализ в Pandas</a></h1><blockquote>
<p>Привет! Продолжем изучать Pandas. В&nbsp;прошлый раз я&nbsp;<a href="http://smysl.io/blog/pandas/">рассказал о&nbsp;возможностях библиотеки </a>, а&nbsp;сегодня покажу, как с&nbsp;её помощью делать когортный анализ.</p>
</blockquote>
<p>Прежде всего, вспомним, что такое когорты и&nbsp;как их&nbsp;анализировать.</p>
<div style="padding: 1rem 1rem 0 1rem;"><p style="font-family: graphik-regular; font-size: .9rem;">Когорта&nbsp;&mdash; это группа людей, которая совершила нужное действие в&nbsp;определенный промежуток времени.</p><p style="font-family: graphik-regular; font-size: .9rem;">Когортный анализ&nbsp;&mdash; это наблюдение за&nbsp;когортами. Выбираем одну или несколько метрик, измеряем их&nbsp;и&nbsp;делаем выводы.</p><br></div>

<p>Например, социологи могут отслеживать, сколько людей, родившихся в&nbsp;1980 году, получили высшее образование. Когорта здесь&nbsp;&mdash; те, кто родились в&nbsp;1980 году. Метрика&nbsp;&mdash; доля людей с&nbsp;высшим образованием.</p>
<p>Еще пример: маркетологи хотят узнать, сколько заказов и&nbsp;выручки принесли пользователи, совершившие свой первый заказ год назад. Теперь когорта&nbsp;&mdash; это прошлогодние покупатели, а&nbsp;метрики&nbsp;&mdash; количество заказов и&nbsp;выручка.</p>
<p>Получается, когортный анализ состоит из&nbsp;трех шагов: определения нужного действия и&nbsp;временного промежутка когорты и&nbsp;выбора метрик для отслеживания:</p>
<table>
<thead>
<tr>
<th style="text-align:left">Действие</th>
<th style="text-align:left">Время</th>
<th style="text-align:left">Метрика</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Родились</td>
<td style="text-align:left">В&nbsp;1980 году</td>
<td style="text-align:left">% людей с&nbsp;высшим образованием</td>
</tr>
<tr>
<td style="text-align:left">Впервые <nobr>что-то</nobr> купили</td>
<td style="text-align:left">Год назад</td>
<td style="text-align:left">Количество заказов и&nbsp;выручка</td>
</tr>
<tr>
<td style="text-align:left">Установили приложение</td>
<td style="text-align:left">Неделю назад</td>
<td style="text-align:left">% пользователей, открывших приложение еще раз</td>
</tr>
</tbody>
</table>
<p>Когорты можно сравнивать между собой. Например, маркетологи измеряют, сколько заказов обычно делают пользователи в&nbsp;течение месяца после первой покупки и&nbsp;смотрят динамику:</p>
<table>
<thead>
<tr>
<th style="text-align:left">Месяц</th>
<th style="text-align:right">Клиенты</th>
<th style="text-align:right">Покупок в&nbsp;1й месяц</th>
<th style="text-align:right">Покупок на&nbsp;клиента</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Январь 2018</td>
<td style="text-align:right">134</td>
<td style="text-align:right">161</td>
<td style="text-align:right">1.20</td>
</tr>
<tr>
<td style="text-align:left">Февраль 2018</td>
<td style="text-align:right">164</td>
<td style="text-align:right">194</td>
<td style="text-align:right">1.18</td>
</tr>
<tr>
<td style="text-align:left">Март 2018</td>
<td style="text-align:right"><span class="green"><strong>193</strong></span></td>
<td style="text-align:right"><span class="green"><strong>200</strong></span></td>
<td style="text-align:right"><span class="red"><strong>1.03</strong></span></td>
</tr>
</tbody>
</table>
<p>Общее количество клиентов и&nbsp;покупок выросло&nbsp;&mdash; приятно. Но, сравнив когорты, видим, что в&nbsp;среднем клиенты стали покупать реже&nbsp;&mdash; тревожный знак.</p>
<p>Ок, теперь мы&nbsp;готовы к&nbsp;тому, чтобы научиться делать когортный анализ с&nbsp;помощью Pandas. Для наглядности решим задачу.</p>
<h2 id="Задача"><a href="#Задача" class="headerlink" title="Задача"></a>Задача</h2><p>Допустим, мы&nbsp;работаем в&nbsp;<nobr>интернет-магазине</nobr> и&nbsp;хотим понять, сколько заказов и&nbsp;денег клиенты приносят в&nbsp;течение года после первой покупки. Для этого у&nbsp;нас есть <a href="http://smysl.io/data/pandas/orders.csv">данные о&nbsp;заказах</a>:</p>
<script src="https://gist.github.com/kulichevskiy/867460c17cb66d5860cebd5964b231ec.js"></script>

<p>Каждая строка таблицы <code>orders</code>&nbsp;&mdash; это покупка. Мы&nbsp;знаем, когда она произошла, кто её сделал и&nbsp;сколько денег она принесла в&nbsp;магазин. Дата заказа лежит в&nbsp;поле <code>order_date</code>, номер покупателя&nbsp;&mdash; в&nbsp;<code>customer_id</code>, а&nbsp;выручка&nbsp;&mdash; в&nbsp;<code>sales</code>.</p>
<p>Часто бывает, что даты загружаются в&nbsp;виде текста. Преобразим колонку <code>order_date</code> из&nbsp;текста в&nbsp;дату:</p>
<script src="https://gist.github.com/kulichevskiy/5f49b1d5a58884b4f4666d28a1fc37c2.js"></script>

<p>Данные перед нами, теперь можно с&nbsp;ними работать. Начнем с&nbsp;простого: выясним, сколько всего в&nbsp;магазине было покупок и&nbsp;выручки.</p>
<h2 id="Считаем-покупки-и-nbsp-выручку"><a href="#Считаем-покупки-и-nbsp-выручку" class="headerlink" title="Считаем покупки и&nbsp;выручку"></a>Считаем покупки и&nbsp;выручку</h2><p>Чтобы посчитать общую выручку, просуммируем колонку <code>sales</code>:</p>
<script src="https://gist.github.com/kulichevskiy/5b510516c6cc33179c743d348b9bc01b.js"></script>

<p>Количество заказов можно посчитать с&nbsp;помощью этой&nbsp;же колонки, но&nbsp;вместо суммы используем метод <code>count()</code>:</p>
<script src="https://gist.github.com/kulichevskiy/ef1321544a45b172c589062bf9d0a396.js"></script>

<p>Теперь посчитаем обе метрики для каждого пользователя. Сгруппируем датафрейм по&nbsp;полю <code>customer_id</code>:</p>
<script src="https://gist.github.com/kulichevskiy/6c754554a2b96e7fe9ce8530042059f5.js"></script>

<p>Видим, например, что пользователь AA-10315 сделал 5 заказов и&nbsp;принес $5563 выручки.</p>
<p>Идём дальше. Чтобы построить когорты, нам нужно сгруппировать клиентов по&nbsp;дате их&nbsp;первой покупки. В&nbsp;данных нет такого поля, значит, нужно его посчитать.</p>
<h2 id="Считаем-дату-первой-покупки"><a href="#Считаем-дату-первой-покупки" class="headerlink" title="Считаем дату первой покупки"></a>Считаем дату первой покупки</h2><p>Чтобы вычислить дату первой покупки каждого пользователя, сгруппируем данные по&nbsp;<code>customer_id</code> и&nbsp;найдем минимальное значение поля <code>order_date</code>. Результат сохраним в&nbsp;переменную <code>first_orders</code>:</p>
<script src="https://gist.github.com/kulichevskiy/15683789197f08e2fda93b6b708396a8.js"></script>

<p>Видим, что пользовать AA-10315 впервые что-то купил 31&nbsp;марта 2014 года, а&nbsp;пользователь AA-10375&nbsp;&mdash; 21 апреля того&nbsp;же года.</p>
<p>Зная даты первых покупок, можем строить когорты.</p>
<h2 id="Строим-когорты"><a href="#Строим-когорты" class="headerlink" title="Строим когорты"></a>Строим когорты</h2><p>Итак, когортами будем считать людей, сделавших первую покупку в&nbsp;тот или иной день. Метрики для отслеживания&nbsp;&mdash; количество заказов и&nbsp;выручка.</p>
<p>План такой: сначала добавим дату первой покупки пользователей в&nbsp;таблицу с&nbsp;заказами, затем сгруппируем по&nbsp;датам первой покупки и&nbsp;заказа и, наконец, посчитаем выручку и&nbsp;количество заказов каждой когорты.</p>
<p>Приступим. Добавим дату первой покупки с&nbsp;помощью метода <code>merge()</code> и&nbsp;сохраним получившийся датафрейм в&nbsp;переменную <code>orders_merged</code>:</p>
<script src="https://gist.github.com/kulichevskiy/a0a3ad5229ab82dfc7aa900fd52a1389.js"></script>

<p>В&nbsp;строках получившегося датафрейма всё еще покупки, но&nbsp;теперь в&nbsp;таблице появилась новая колонка: дата первой покупки пользователя.</p>
<p>Агрегируем по&nbsp;дате первой покупки и&nbsp;посчитаем нужные показатели:</p>
<script src="https://gist.github.com/kulichevskiy/a63ad68004c7181459117e10e7685a8c.js"></script>

<p>Видим, что клиенты от&nbsp;3 января 2014 года, всего сделали 9 заказов на&nbsp;$1050.6. Посмотрим, когда были эти заказы. Для этого добавим к&nbsp;группировке колонку <code>order_date</code>:</p>
<script src="https://gist.github.com/kulichevskiy/d6622170915e1c0bb3cf312ce3c33c90.js"></script>

<p>Ага, первый заказ этой когорты был 3 января на&nbsp;$16. В&nbsp;следующий раз клиент вернулся почти год спустя и&nbsp;купил что-то ещё, в&nbsp;этот раз на&nbsp;$153. Следующая покупка была уже в&nbsp;апреле 2015 и&nbsp;так далее.</p>
<p>Когорты готовы, теперь решим задачу.</p>
<h2 id="Решаем-задачу"><a href="#Решаем-задачу" class="headerlink" title="Решаем задачу"></a>Решаем задачу</h2><p>Напомню, что мы&nbsp;хотим посчитать, сколько в&nbsp;среднем заказов и&nbsp;выручки приносят клиенты в&nbsp;течение года, после первой покупки.</p>
<p>Мы&nbsp;знаем, сколько магазин заработал с&nbsp;каждой когорты за&nbsp;всё время. Уточним метрику: посчитаем показатели за&nbsp;первый год жизни когорты.</p>
<p>Сначала узнаем, сколько дней прошло между первой покупкой и&nbsp;последующим заказом, и&nbsp;удалим те, которые случились позже 365 дней. Чтобы посчитать количество дней между заказами, вычтем из&nbsp;колонки <code>order_date</code> столбец <code>first_order</code>:</p>
<script src="https://gist.github.com/kulichevskiy/8bbddaf50f03229dd679464096cc5222.js"></script>

<p>Вуаля. Видим, что, например, заказ <code>131884</code> случился 455 дней спустя первой покупки. <code>455 days</code>&nbsp;&mdash; это тип данных под названием &laquo;Timedelta&raquo;, его специально придумали, чтобы показывать временные промежутки.</p>
<p>Чтобы удалить поздние заказы, добавим условие <code>&lt;= &#39;365 days&#39;</code>:</p>
<script src="https://gist.github.com/kulichevskiy/8f6fab19b19d71618d3e0caecc62c0c7.js"></script>

<p>Сохраним результат в&nbsp;переменную <code>year_1_filter</code>, отфильтруем ненужные заказы из&nbsp;когортного отчета и&nbsp;сохраним результат в&nbsp;переменную <code>year_1_orders</code>:</p>
<script src="https://gist.github.com/kulichevskiy/254ca799d9002cef15f819c709a1b097.js"></script>

<p>В&nbsp;датафрейме остались только заказы, сделанные когортами в&nbsp;первый год после первой покупки. Теперь сгруппируем заказы по&nbsp;дате первой покупки и&nbsp;посчитаем нужные метрики. Результат сохраним в&nbsp;переменную <code>cohorts</code>:</p>
<script src="https://gist.github.com/kulichevskiy/5ddefa4d38848a2ac4d4066ffdcda393.js"></script>

<p>Последний шаг: посчитаем, сколько в&nbsp;среднем заказов и&nbsp;приносят клиенты в&nbsp;течение первого года. Для этого сначала просуммируем показатели каждой когорты, а&nbsp;затем усредним значения методом <code>mean()</code>:</p>
<script src="https://gist.github.com/kulichevskiy/adec10491e67999ff692f1ff2fe8ef6d.js"></script>

<p>Готово! В&nbsp;среднем за&nbsp;первый год когорты делают по&nbsp;4 заказа и&nbsp;приносят по&nbsp;$1949&nbsp;долларов.</p>
<p>Есть много способов улучшить решение, например сгруппировать дневные когорты в&nbsp;недельные или месячные, визуализировать отчет в&nbsp;таблице или на&nbsp;графике. Наконец, интересно разбить когорты по&nbsp;каким-то признакам, например, отделить частных покупателей от&nbsp;компаний&nbsp;&mdash; наверняка их&nbsp;показатели существенно отличаются.</p>
<p>Обо&nbsp;всем этом в&nbsp;следующих сериях. Подписывайтесь на&nbsp;<a href="https://t.me/kulichevskiy" target="_blank" rel="noopener">канал</a>, чтобы не&nbsp;пропустить. Ну&nbsp;и&nbsp;да, <a href="https://brainwashing.pro/marketing-python" target="_blank" rel="noopener">приходите учиться на&nbsp;курс</a>!</p>
<p>Адиос!</p>
<p><em>Cпасибо Наташе Асаул за&nbsp;то, что помогла отредактировать статью.</em></p>
</div></div></div><div class="container container_margin"><div class="row"><div class="col-md-8 col-sm-12"><h1><a href="/blog/pandas/">Аналитикам: большая шпаргалка по Pandas</a></h1><blockquote>
<p>Привет. Я&nbsp;задумывал эту заметку для студентов курса <a href="https://digitalgod.be/rockstar" target="_blank" rel="noopener">Digital Rockstar</a>, на&nbsp;котором мы&nbsp;учим маркетологов автоматизировать свою работу с&nbsp;помощью программирования, но&nbsp;решил поделиться шпаргалкой по&nbsp;Pandas со&nbsp;всеми. Я&nbsp;ожидаю, что читатель умеет писать код на&nbsp;Python хотя&nbsp;бы на&nbsp;минимальном уровне, знает, что такое списки, словари, циклы и&nbsp;функции.</p>
</blockquote>
<ol>
<li><a href="#Что-такое-Pandas-и-зачем-он-нужен">Что такое Pandas и&nbsp;зачем он&nbsp;нужен</a></li>
<li><a href="#Структуры-данных">Структуры данных: серии и&nbsp;датафреймы</a></li>
<li><a href="#Создаем-датафреймы-и-загружаем-в-них-данные">Создаем датафреймы и&nbsp;загружаем в&nbsp;них данные</a></li>
<li><a href="#Исследуем-загруженные-данные">Исследуем загруженные данные</a></li>
<li><a href="#Получаем-данные-из-датафреймов">Получаем данные из&nbsp;датафреймов</a></li>
<li><a href="#Считаем-производные-метрики">Считаем производные метрики</a></li>
<li><a href="#Объединяем-несколько-датафреймов">Объединяем несколько датафреймов</a></li>
<li><a href="#Решаем-задачу">Решаем задачу</a></li>
</ol>
<h2 id="Что-такое-Pandas-и-nbsp-зачем-он-nbsp-нужен"><a href="#Что-такое-Pandas-и-nbsp-зачем-он-nbsp-нужен" class="headerlink" title="Что такое Pandas и&nbsp;зачем он&nbsp;нужен"></a>Что такое Pandas и&nbsp;зачем он&nbsp;нужен</h2><p>Pandas&nbsp;&mdash; это библиотека для работы с&nbsp;данными на&nbsp;Python. Она упрощает жизнь аналитикам: где раньше использовалось 10 строк кода теперь хватит одной.</p>
<p>Например, чтобы прочитать данные из&nbsp;csv, в&nbsp;стандартном Python надо сначала решить, как хранить данные, затем открыть файл, прочитать его построчно, отделить значения друг от&nbsp;друга и&nbsp;очистить данные от&nbsp;специальных символов.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">with</span> open(<span class="string">'file.csv'</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">... </span>   content = f.readlines()</span><br><span class="line"><span class="meta">... </span>   content = [x.split(<span class="string">','</span>).replace(<span class="string">'\n'</span>,<span class="string">''</span>) <span class="keyword">for</span> x <span class="keyword">in</span> content]</span><br></pre></td></tr></table></figure>
<p>В&nbsp;Pandas всё проще. Во-первых, не&nbsp;нужно думать, как будут храниться данные&nbsp;&mdash; они лежат в&nbsp;датафрейме. Во-вторых, достаточно написать одну команду:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; data = pd.read_csv(<span class="string">'file.csv'</span>)</span><br></pre></td></tr></table></figure>
<p>Pandas добавляет в&nbsp;Python новые структуры данных&nbsp;&mdash; серии и&nbsp;датафреймы. Расскажу, что это такое.</p>
<h2 id="Структуры-данных-серии-и-nbsp-датафреймы"><a href="#Структуры-данных-серии-и-nbsp-датафреймы" class="headerlink" title="Структуры данных: серии и&nbsp;датафреймы"></a>Структуры данных: серии и&nbsp;датафреймы</h2><p>Серии&nbsp;&mdash; одномерные массивы данных. Они очень похожи на&nbsp;списки, но&nbsp;отличаются по&nbsp;поведению&nbsp;&mdash; например, операции применяются к&nbsp;списку целиком, а&nbsp;в&nbsp;сериях&nbsp;&mdash; поэлементно.</p>
<p>То&nbsp;есть, если список умножить на&nbsp;2, получите тот&nbsp;же список, повторенный 2 раза.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; vector = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&gt; vector * <span class="number">2</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>А если умножить серию, ее длина не изменится, а вот элементы удвоятся.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">&gt; series = pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">&gt; series * <span class="number">2</span></span><br><span class="line"><span class="number">0</span>    <span class="number">2</span></span><br><span class="line"><span class="number">1</span>    <span class="number">4</span></span><br><span class="line"><span class="number">2</span>    <span class="number">6</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>Обратите внимание на&nbsp;первый столбик вывода. Это индекс, в&nbsp;котором хранятся адреса каждого элемента серии. Каждый элемент потом можно получать, обратившись по&nbsp;нужному адресу.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; series = pd.Series([<span class="string">'foo'</span>, <span class="string">'bar'</span>])</span><br><span class="line">&gt; series[<span class="number">0</span>]</span><br><span class="line"><span class="string">'foo'</span></span><br></pre></td></tr></table></figure>
<p>Еще одно отличие серий от&nbsp;списков&nbsp;&mdash; в&nbsp;качестве индексов можно использовать произвольные значения, это делает данные нагляднее. Представим, что мы&nbsp;анализируем помесячные продажи. Используем в&nbsp;качестве индексов названия месяцев, значениями будет выручка:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; months = [<span class="string">'jan'</span>, <span class="string">'feb'</span>, <span class="string">'mar'</span>, <span class="string">'apr'</span>]</span><br><span class="line">&gt; sales = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>]</span><br><span class="line">&gt; data = pd.Series(data=sales, index=months)</span><br><span class="line">&gt; data</span><br><span class="line">jan    <span class="number">100</span></span><br><span class="line">feb    <span class="number">200</span></span><br><span class="line">mar    <span class="number">300</span></span><br><span class="line">apr    <span class="number">400</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>Теперь можем получать значения каждого месяца:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; data[<span class="string">'feb'</span>]</span><br><span class="line"><span class="number">200</span></span><br></pre></td></tr></table></figure>
<p>Так как серии&nbsp;&mdash; одномерный массив данных, в&nbsp;них удобно хранить измерения по&nbsp;одному. На&nbsp;практике удобнее группировать данные вместе. Например, если мы&nbsp;анализируем помесячные продажи, полезно видеть не&nbsp;только выручку, но&nbsp;и&nbsp;количество проданных товаров, количество новых клиентов и&nbsp;средний чек. Для этого отлично подходят датафреймы.</p>
<p>Датафреймы&nbsp;&mdash; это таблицы. У&nbsp;их&nbsp;есть строки, колонки и&nbsp;ячейки.</p>
<p>Технически, колонки датафреймов&nbsp;&mdash; это серии. Поскольку в&nbsp;колонках обычно описывают одни и&nbsp;те&nbsp;же объекты, то&nbsp;все колонки делят один и&nbsp;тот&nbsp;же индекс:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; months = [<span class="string">'jan'</span>, <span class="string">'feb'</span>, <span class="string">'mar'</span>, <span class="string">'apr'</span>]</span><br><span class="line">&gt; sales = &#123;</span><br><span class="line"><span class="meta">... </span>   <span class="string">'revenue'</span>:     [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>],</span><br><span class="line"><span class="meta">... </span>   <span class="string">'items_sold'</span>:  [<span class="number">23</span>, <span class="number">43</span>, <span class="number">55</span>, <span class="number">65</span>],</span><br><span class="line"><span class="meta">... </span>   <span class="string">'new_clients'</span>: [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]</span><br><span class="line">...&#125;</span><br><span class="line">&gt; sales_df = pd.DataFrame(data=sales, index=months)</span><br><span class="line">&gt; sales_df</span><br><span class="line">     revenue  items_sold  new_clients</span><br><span class="line">jan      <span class="number">100</span>          <span class="number">23</span>           <span class="number">10</span></span><br><span class="line">feb      <span class="number">200</span>          <span class="number">43</span>           <span class="number">20</span></span><br><span class="line">mar      <span class="number">300</span>          <span class="number">55</span>           <span class="number">30</span></span><br><span class="line">apr      <span class="number">400</span>          <span class="number">65</span>           <span class="number">40</span></span><br></pre></td></tr></table></figure>
<p>Объясню, как создавать датафреймы и&nbsp;загружать в&nbsp;них данные.</p>
<h2 id="Создаем-датафреймы-и-nbsp-загружаем-данные"><a href="#Создаем-датафреймы-и-nbsp-загружаем-данные" class="headerlink" title="Создаем датафреймы и&nbsp;загружаем данные"></a>Создаем датафреймы и&nbsp;загружаем данные</h2><p>Бывает, что мы&nbsp;не&nbsp;знаем, что собой представляют данные, и&nbsp;не&nbsp;можем задать структуру заранее. Тогда удобно создать пустой датафрейм и&nbsp;позже наполнить его данными.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; df = pd.DataFrame()</span><br></pre></td></tr></table></figure>
<p>А&nbsp;иногда данные уже есть, но&nbsp;хранятся в&nbsp;переменной из&nbsp;стандартного Python, например, в&nbsp;словаре. Чтобы получить датафрейм, эту переменную передаем в&nbsp;ту&nbsp;же команду:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; df = pd.DataFrame(data=sales, index=months))</span><br></pre></td></tr></table></figure>
<p>Случается, что в&nbsp;некоторых записях не&nbsp;хватает данных. Например, посмотрите на&nbsp;список <code>goods_sold</code>&nbsp;&mdash; в&nbsp;нём продажи, разбитые по&nbsp;товарным категориям. За&nbsp;первый месяц мы&nbsp;продали машины, компьютеры и&nbsp;программное обеспечение. Во&nbsp;втором машин нет, зато появились велосипеды, а&nbsp;в&nbsp;третьем снова появились машины, но&nbsp;велосипеды исчезли:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; goods_sold = [</span><br><span class="line"><span class="meta">... </span>    &#123;<span class="string">'computers'</span>: <span class="number">10</span>, <span class="string">'cars'</span>: <span class="number">1</span>, <span class="string">'soft'</span>: <span class="number">3</span>&#125;,</span><br><span class="line"><span class="meta">... </span>    &#123;<span class="string">'computers'</span>: <span class="number">4</span>, <span class="string">'soft'</span>: <span class="number">5</span>, <span class="string">'bicycles'</span>: <span class="number">1</span>&#125;,</span><br><span class="line"><span class="meta">... </span>    &#123;<span class="string">'computers'</span>: <span class="number">6</span>, <span class="string">'cars'</span>: <span class="number">2</span>, <span class="string">'soft'</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">... </span>]</span><br></pre></td></tr></table></figure>
<p>Если загрузить данные в&nbsp;датафрейм, Pandas создаст колонки для всех товарных категорий и, где это возможно, заполнит их&nbsp;данными:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; pd.DataFrame(goods_sold)</span><br><span class="line">   bicycles  cars  computers  soft</span><br><span class="line"><span class="number">0</span>       NaN   <span class="number">1.0</span>         <span class="number">10</span>     <span class="number">3</span></span><br><span class="line"><span class="number">1</span>       <span class="number">1.0</span>   NaN          <span class="number">4</span>     <span class="number">5</span></span><br><span class="line"><span class="number">2</span>       NaN   <span class="number">2.0</span>          <span class="number">6</span>     <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>Обратите внимание, продажи велосипедов в&nbsp;первом и&nbsp;третьем месяце равны <code>NaN</code>&nbsp;&mdash; расшифровывается как Not a&nbsp;Number. Так Pandas помечает отсутствующие значения.</p>
<p>Теперь разберем, как загружать данные из&nbsp;файлов. Чаще всего данные хранятся в&nbsp;экселевских таблицах или csv-, tsv- файлах.</p>
<p>Экселевские таблицы читаются с&nbsp;помощью команды <code>pd.read_excel()</code>. Параметрами нужно передать адрес файла на&nbsp;компьютере и&nbsp;название листа, который нужно прочитать. Команда работает как&nbsp;с&nbsp;xls, так и&nbsp;с&nbsp;xlsx:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; pd.read_excel(<span class="string">'file.xlsx'</span>, sheet_name=<span class="string">'Sheet1'</span>)</span><br></pre></td></tr></table></figure>
<p>Файлы формата csv и&nbsp;tsv&nbsp;&mdash; это текстовые файлы, в&nbsp;которых данные отделены друг от&nbsp;друга запятыми или табуляцией:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CSV</span></span><br><span class="line">month,customers,sales</span><br><span class="line">feb,<span class="number">10</span>,<span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TSV</span></span><br><span class="line">month\tcustomers\tsales</span><br><span class="line">feb\t10\t200</span><br></pre></td></tr></table></figure>
<p>Оба читаются с&nbsp;помощью команды <code>.read_csv()</code>, символ табуляции передается параметром <code>sep</code> (от&nbsp;англ. <em>separator</em>&nbsp;&mdash; разделитель):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; pd.read_csv(<span class="string">'file.csv'</span>)</span><br><span class="line">&gt; pd.read_csv(<span class="string">'file.tsv'</span>, sep=<span class="string">'\t'</span>)</span><br></pre></td></tr></table></figure>
<p>При загрузке можно назначить столбец, который будет индексом. Представьте, что мы&nbsp;загружаем таблицу с&nbsp;заказами. У&nbsp;каждого заказа есть свой уникальный номер, Если назначим этот номер индексом, сможем выгружать данные командой <code>df[order_id]</code>. Иначе придется писать фильтр <code>df[df[‘id’] == order_id ]</code>.</p>
<p>О&nbsp;том, как получать данные из&nbsp;датафреймов, я&nbsp;расскажу в&nbsp;одном из&nbsp;следующих разделов. Чтобы назначить колонку индексом, добавим в&nbsp;команду <code>read_csv()</code> параметр <code>index_col</code>, равный названию нужной колонки:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; pd.read_csv(<span class="string">'file.csv'</span>, index_col=<span class="string">'id'</span>)</span><br></pre></td></tr></table></figure>
<p>После загрузки данных в&nbsp;датафрейм, хорошо&nbsp;бы их&nbsp;исследовать&nbsp;&mdash; особенно, если они вам незнакомы.</p>
<h2 id="Исследуем-загруженные-данные"><a href="#Исследуем-загруженные-данные" class="headerlink" title="Исследуем загруженные данные"></a>Исследуем загруженные данные</h2><p>Представим, что мы&nbsp;анализируем продажи американского интернет-магазина. У&nbsp;нас есть данные о&nbsp;заказах и&nbsp;клиентах. Загрузим файл с&nbsp;продажами интернет-магазина в&nbsp;переменную <code>orders</code>. Раз загружаем заказы, укажем, что колонка <code>id</code> пойдет в&nbsp;индекс:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; orders = pd.read_csv(<span class="string">'orders.csv'</span>, index_col=<span class="string">'id'</span>)</span><br></pre></td></tr></table></figure>
<p>Расскажу о&nbsp;четырех атрибутах, которые есть у&nbsp;любого датафрейма: <code>.shape</code>, <code>.columns</code>, <code>.index</code> и&nbsp;<code>.dtypes</code>.</p>
<p><code>.shape</code> показывает, сколько в&nbsp;датафрейме строк и&nbsp;колонок. Он&nbsp;возвращает пару значений <code>(n_rows, n_columns)</code>. Сначала идут строки, потом колонки.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; orders.shape</span><br><span class="line">(<span class="number">5009</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>В&nbsp;датафрейме 5009 строк и&nbsp;5 колонок.</p>
<p>Окей, масштаб оценили. Теперь посмотрим, какая информация содержится в&nbsp;каждой колонке. С&nbsp;помощью <code>.columns</code> узнаем названия колонок:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; orders.columns</span><br><span class="line">Index([<span class="string">'order_date'</span>, <span class="string">'ship_mode'</span>, <span class="string">'customer_id'</span>, <span class="string">'sales'</span>], dtype=<span class="string">'object'</span>)</span><br></pre></td></tr></table></figure>
<p>Теперь видим, что в&nbsp;таблице есть дата заказа, метод доставки, номер клиента и&nbsp;выручка.</p>
<p>С&nbsp;помощью <code>.dtypes</code> узнаем типы данных, находящихся в&nbsp;каждой колонке и&nbsp;поймем, надо&nbsp;ли их&nbsp;обрабатывать. Бывает, что числа загружаются в&nbsp;виде текста. Если мы&nbsp;попробуем сложить две текстовых значения <code>&#39;1&#39; + &#39;1&#39;</code>, то&nbsp;получим не&nbsp;число 2, а&nbsp;строку <code>&#39;11&#39;</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; orders.dtypes</span><br><span class="line">order_date      object</span><br><span class="line">ship_mode       object</span><br><span class="line">customer_id     object</span><br><span class="line">sales          float64</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure>
<p>Тип <code>object</code>&nbsp;&mdash; это текст, <code>float64</code>&nbsp;&mdash; это дробное число типа 3,14.</p>
<p>C&nbsp;помощью атрибута <code>.index</code> посмотрим, как называются строки:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; orders.index</span><br><span class="line">Int64Index([<span class="number">100006</span>, <span class="number">100090</span>, <span class="number">100293</span>, <span class="number">100328</span>, <span class="number">100363</span>, <span class="number">100391</span>, <span class="number">100678</span>, <span class="number">100706</span>,</span><br><span class="line">            <span class="number">100762</span>, <span class="number">100860</span>,</span><br><span class="line">            ...</span><br><span class="line">            <span class="number">167570</span>, <span class="number">167920</span>, <span class="number">168116</span>, <span class="number">168613</span>, <span class="number">168690</span>, <span class="number">168802</span>, <span class="number">169320</span>, <span class="number">169488</span>,</span><br><span class="line">            <span class="number">169502</span>, <span class="number">169551</span>],</span><br><span class="line">           dtype=<span class="string">'int64'</span>, name=<span class="string">'id'</span>, length=<span class="number">5009</span>)</span><br></pre></td></tr></table></figure>
<p>Ожидаемо, в&nbsp;индексе датафрейма номера заказов: 100762, 100860 и&nbsp;так далее.</p>
<p>В&nbsp;колонке <code>sales</code> хранится стоимость каждого проданного товара. Чтобы узнать разброс значений, среднюю стоимость и&nbsp;медиану, используем метод <code>.describe()</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; orders.describe()</span><br><span class="line">         sales</span><br><span class="line">count   <span class="number">5009.0</span></span><br><span class="line">mean     <span class="number">458.6</span></span><br><span class="line">std      <span class="number">954.7</span></span><br><span class="line">min        <span class="number">0.6</span></span><br><span class="line"><span class="number">25</span>%       <span class="number">37.6</span></span><br><span class="line"><span class="number">50</span>%      <span class="number">152.0</span></span><br><span class="line"><span class="number">75</span>%      <span class="number">512.1</span></span><br><span class="line">max    <span class="number">23661.2</span></span><br></pre></td></tr></table></figure>
<p>Наконец, чтобы посмотреть на&nbsp;несколько примеров записей датафрейма, используем команды <code>.head()</code> и&nbsp;<code>.sample()</code>. Первая возвращает 6 записей из&nbsp;начала датафрейма. Вторая&nbsp;&mdash; 6 случайных записей:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; orders.head()</span><br><span class="line">        order_date ship_mode customer_id    sales</span><br><span class="line">id                                                                         </span><br><span class="line"><span class="number">100006</span>  <span class="number">2014</span><span class="number">-09</span><span class="number">-07</span>  Standard    DK<span class="number">-13375</span>  <span class="number">377.970</span></span><br><span class="line"><span class="number">100090</span>  <span class="number">2014</span><span class="number">-07</span><span class="number">-08</span>  Standard    EB<span class="number">-13705</span>  <span class="number">699.192</span></span><br><span class="line"><span class="number">100293</span>  <span class="number">2014</span><span class="number">-03</span><span class="number">-14</span>  Standard    NF<span class="number">-18475</span>   <span class="number">91.056</span></span><br><span class="line"><span class="number">100328</span>  <span class="number">2014</span><span class="number">-01</span><span class="number">-28</span>  Standard    JC<span class="number">-15340</span>    <span class="number">3.928</span></span><br><span class="line"><span class="number">100363</span>  <span class="number">2014</span><span class="number">-04</span><span class="number">-08</span>  Standard    JM<span class="number">-15655</span>   <span class="number">21.376</span></span><br></pre></td></tr></table></figure>
<p>Получив первое представление о&nbsp;датафреймах, теперь обсудим, как доставать из&nbsp;него данные.</p>
<h2 id="Получаем-данные-из-nbsp-датафреймов"><a href="#Получаем-данные-из-nbsp-датафреймов" class="headerlink" title="Получаем данные из&nbsp;датафреймов"></a>Получаем данные из&nbsp;датафреймов</h2><p>Данные из&nbsp;датафреймов можно получать по-разному: указав номера колонок и&nbsp;строк, использовав условные операторы или язык запросов. Расскажу подробнее о&nbsp;каждом способе.</p>
<h3 id="Указываем-нужные-строки-и-nbsp-колонки"><a href="#Указываем-нужные-строки-и-nbsp-колонки" class="headerlink" title="Указываем нужные строки и&nbsp;колонки"></a>Указываем нужные строки и&nbsp;колонки</h3><p>Продолжаем анализировать продажи интернет-магазина, которые загрузили в&nbsp;предыдущем разделе. Допустим, я&nbsp;хочу вывести столбец <code>sales</code>. Для этого название столбца нужно заключить в&nbsp;квадратные скобки и&nbsp;поставить после них названия датафрейма: <code>orders[&#39;sales&#39;]</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; orders[<span class="string">'sales'</span>]</span><br><span class="line">id</span><br><span class="line"><span class="number">100006</span>     <span class="number">377.970</span></span><br><span class="line"><span class="number">100090</span>     <span class="number">699.192</span></span><br><span class="line"><span class="number">100293</span>      <span class="number">91.056</span></span><br><span class="line"><span class="number">100328</span>       <span class="number">3.928</span></span><br><span class="line"><span class="number">100363</span>      <span class="number">21.376</span></span><br><span class="line"><span class="number">100391</span>      <span class="number">14.620</span></span><br><span class="line"><span class="number">100678</span>     <span class="number">697.074</span></span><br><span class="line"><span class="number">100706</span>     <span class="number">129.440</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Обратите внимание, результат команды&nbsp;&mdash; новый датафрейм с&nbsp;таким&nbsp;же индексом.</p>
<p>Если нужно вывести несколько столбцов, в&nbsp;квадратные скобки нужно вставить список с&nbsp;их&nbsp;названиями: <code>orders[[&#39;customer_id&#39;, &#39;sales&#39;]]</code>. Будьте внимательны: квадратные скобки стали двойными. Первые&nbsp;&mdash; от&nbsp;датафрейма, вторые&nbsp;&mdash; от&nbsp;списка:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; orders[[<span class="string">'customer_id'</span>, <span class="string">'sales'</span>]]</span><br><span class="line">       customer_id     sales</span><br><span class="line">id                                  </span><br><span class="line"><span class="number">100006</span>    DK<span class="number">-13375</span>   <span class="number">377.970</span></span><br><span class="line"><span class="number">100090</span>    EB<span class="number">-13705</span>   <span class="number">699.192</span></span><br><span class="line"><span class="number">100293</span>    NF<span class="number">-18475</span>    <span class="number">91.056</span></span><br><span class="line"><span class="number">100328</span>    JC<span class="number">-15340</span>     <span class="number">3.928</span></span><br><span class="line"><span class="number">100363</span>    JM<span class="number">-15655</span>    <span class="number">21.376</span></span><br><span class="line"><span class="number">100391</span>    BW<span class="number">-11065</span>    <span class="number">14.620</span></span><br><span class="line"><span class="number">100363</span>    KM<span class="number">-16720</span>   <span class="number">697.074</span></span><br><span class="line"><span class="number">100706</span>    LE<span class="number">-16810</span>   <span class="number">129.440</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Перейдем к&nbsp;строкам. Их&nbsp;можно фильтровать по&nbsp;индексу и&nbsp;по&nbsp;порядку. Например, мы&nbsp;хотим вывести только заказы 100363, 100391 и&nbsp;100706, для этого есть команда <code>.loc[]</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; show_these_orders = [<span class="string">'100363'</span>, <span class="string">'100363'</span>, <span class="string">'100706'</span>]</span><br><span class="line">&gt; orders.loc[show_these_orders]</span><br><span class="line">        order_date ship_mode customer_id    sales</span><br><span class="line">id                                                             </span><br><span class="line"><span class="number">100363</span>  <span class="number">2014</span><span class="number">-04</span><span class="number">-08</span>  Standard    JM<span class="number">-15655</span>   <span class="number">21.376</span></span><br><span class="line"><span class="number">100363</span>  <span class="number">2014</span><span class="number">-04</span><span class="number">-08</span>  Standard    JM<span class="number">-15655</span>   <span class="number">21.376</span></span><br><span class="line"><span class="number">100706</span>  <span class="number">2014</span><span class="number">-12</span><span class="number">-16</span>    Second    LE<span class="number">-16810</span>  <span class="number">129.440</span></span><br></pre></td></tr></table></figure>
<p>А в другой раз бывает нужно достать просто заказы с 1 по 3 по порядку, вне зависимости от их номеров в таблицемы. Тогда используют команду <code>.iloc[]</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; show_these_orders = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&gt; orders.iloc[show_these_orders]</span><br><span class="line">        order_date ship_mode customer_id    sales</span><br><span class="line">id                                                             </span><br><span class="line"><span class="number">100090</span>  <span class="number">2014</span><span class="number">-04</span><span class="number">-08</span>  Standard    JM<span class="number">-15655</span>   <span class="number">21.376</span></span><br><span class="line"><span class="number">100293</span>  <span class="number">2014</span><span class="number">-04</span><span class="number">-08</span>  Standard    JM<span class="number">-15655</span>   <span class="number">21.376</span></span><br><span class="line"><span class="number">100328</span>  <span class="number">2014</span><span class="number">-12</span><span class="number">-16</span>    Second    LE<span class="number">-16810</span>  <span class="number">129.440</span></span><br></pre></td></tr></table></figure>
<p>Можно фильтровать датафреймы по&nbsp;колонкам и&nbsp;столбцам одновременно:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; columns = [<span class="string">'customer_id'</span>, <span class="string">'sales'</span>]</span><br><span class="line">&gt; rows = [<span class="string">'100363'</span>, <span class="string">'100363'</span>, <span class="string">'100706'</span>]</span><br><span class="line">&gt; orders.loc[rows][columns]</span><br><span class="line">       customer_id    sales</span><br><span class="line">id                                 </span><br><span class="line"><span class="number">100363</span>    JM<span class="number">-15655</span>   <span class="number">21.376</span></span><br><span class="line"><span class="number">100363</span>    JM<span class="number">-15655</span>   <span class="number">21.376</span></span><br><span class="line"><span class="number">100706</span>    LE<span class="number">-16810</span>  <span class="number">129.440</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Часто вы&nbsp;не&nbsp;знаете заранее номеров заказов, которые вам нужны. Например, если задача&nbsp;&mdash; получить заказы, стоимостью более 1000&nbsp;рублей. Эту задачу удобно решать с&nbsp;помощью условных операторов.</p>
<h3 id="Если-nbsp-mdash-то-Условные-операторы"><a href="#Если-nbsp-mdash-то-Условные-операторы" class="headerlink" title="Если&nbsp;&mdash; то. Условные операторы"></a>Если&nbsp;&mdash; то. Условные операторы</h3><p>Задача: нужно узнать, откуда приходят самые большие заказы. Начнем с&nbsp;того, что достанем все покупки стоимостью более 1000&nbsp;долларов:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; filter_large = orders[<span class="string">'sales'</span>] &gt; <span class="number">1000</span></span><br><span class="line">&gt; orders.loc[filter_slarge]</span><br><span class="line">        order_date ship_mode customer_id     sales</span><br><span class="line">id                                                             </span><br><span class="line"><span class="number">101931</span>  <span class="number">2014</span><span class="number">-10</span><span class="number">-28</span>     First    TS<span class="number">-21370</span>  <span class="number">1252.602</span></span><br><span class="line"><span class="number">102673</span>  <span class="number">2014</span><span class="number">-11</span><span class="number">-01</span>  Standard    KH<span class="number">-16630</span>  <span class="number">1044.440</span></span><br><span class="line"><span class="number">102988</span>  <span class="number">2014</span><span class="number">-04</span><span class="number">-05</span>    Second    GM<span class="number">-14695</span>  <span class="number">4251.920</span></span><br><span class="line"><span class="number">103100</span>  <span class="number">2014</span><span class="number">-12</span><span class="number">-20</span>     First    AB<span class="number">-10105</span>  <span class="number">1107.660</span></span><br><span class="line"><span class="number">103310</span>  <span class="number">2014</span><span class="number">-05</span><span class="number">-10</span>  Standard    GM<span class="number">-14680</span>  <span class="number">1769.784</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Помните, в&nbsp;начале статьи я&nbsp;упоминал, что в&nbsp;сериях все операции применяются по-элементно? Так вот, операция <code>orders[&#39;sales&#39;] &gt; 1000</code> идет по&nbsp;каждому элементу серии и, если условие выполняется, возвращает <code>True</code>. Если не&nbsp;выполняется&nbsp;&mdash; <code>False</code>. Получившуюся серию мы&nbsp;сохраняем в&nbsp;переменную <code>filter_large</code>.</p>
<p>Вторая команда фильтрует строки датафрейма с&nbsp;помощью серии. Если элемент <code>filter_large</code> равен <code>True</code>, заказ отобразится, если <code>False</code>&nbsp;&mdash; нет. Результат&nbsp;&mdash; датафрейм с&nbsp;заказами, стоимостью более 1000&nbsp;долларов.</p>
<p>Интересно, сколько дорогих заказов было доставлено первым классом? Добавим в&nbsp;фильтр ещё одно условие:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; filter_large = df[<span class="string">'sales'</span>] &gt; <span class="number">1000</span></span><br><span class="line">&gt; filter_first_class = orders[<span class="string">'ship_mode'</span>] == <span class="string">'First'</span></span><br><span class="line">&gt; orders.loc[filter_large &amp; filter_first_class]</span><br><span class="line">        order_date ship_mode customer_id     sales</span><br><span class="line">id                                                           </span><br><span class="line"><span class="number">101931</span>  <span class="number">2014</span><span class="number">-10</span><span class="number">-28</span>     First    TS<span class="number">-21370</span>  <span class="number">1252.602</span></span><br><span class="line"><span class="number">103100</span>  <span class="number">2014</span><span class="number">-12</span><span class="number">-20</span>     First    AB<span class="number">-10105</span>  <span class="number">1107.660</span></span><br><span class="line"><span class="number">106726</span>  <span class="number">2014</span><span class="number">-12</span><span class="number">-06</span>     First    RS<span class="number">-19765</span>  <span class="number">1261.330</span></span><br><span class="line"><span class="number">112158</span>  <span class="number">2014</span><span class="number">-12</span><span class="number">-02</span>     First    DP<span class="number">-13165</span>  <span class="number">1050.600</span></span><br><span class="line"><span class="number">116666</span>  <span class="number">2014</span><span class="number">-05</span><span class="number">-08</span>     First    KT<span class="number">-16480</span>  <span class="number">1799.970</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Логика не&nbsp;изменилась. В&nbsp;переменную <code>filter_large</code> сохранили серию, удовлетворяющую условию <code>orders[&#39;sales&#39;] &gt; 1000</code>. В&nbsp;<code>filter_first_class</code>&nbsp;&mdash; серию, удовлетворяющую <code>orders[&#39;ship_mode&#39;] == &#39;First&#39;</code>.</p>
<p>Затем объединили обе серии с&nbsp;помощью логического ‘И’: <code>filter_first_class &amp; filter_first_class</code>. Получили новую серию той&nbsp;же длины, в&nbsp;элементах которой <code>True</code> только у&nbsp;заказов, стоимостью больше 1000, доставленных первым классом. Таких условий может быть сколько угодно.</p>
<h3 id="Язык-запросов"><a href="#Язык-запросов" class="headerlink" title="Язык запросов"></a>Язык запросов</h3><p>Еще один способ решить предыдущую задачу&nbsp;&mdash; использовать язык запросов. Все условия пишем одной строкой <code>&#39;sales &gt; 1000 &amp; ship_mode == &#39;First&#39;</code> и&nbsp;передаем ее&nbsp;в&nbsp;метод <code>.query()</code>. Запрос получается компактнее.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; orders.query(<span class="string">'sales &gt; 1000 &amp; ship_mode == First'</span>)</span><br><span class="line">        order_date ship_mode customer_id     sales</span><br><span class="line">id                                                           </span><br><span class="line"><span class="number">101931</span>  <span class="number">2014</span><span class="number">-10</span><span class="number">-28</span>     First    TS<span class="number">-21370</span>  <span class="number">1252.602</span></span><br><span class="line"><span class="number">103100</span>  <span class="number">2014</span><span class="number">-12</span><span class="number">-20</span>     First    AB<span class="number">-10105</span>  <span class="number">1107.660</span></span><br><span class="line"><span class="number">106726</span>  <span class="number">2014</span><span class="number">-12</span><span class="number">-06</span>     First    RS<span class="number">-19765</span>  <span class="number">1261.330</span></span><br><span class="line"><span class="number">112158</span>  <span class="number">2014</span><span class="number">-12</span><span class="number">-02</span>     First    DP<span class="number">-13165</span>  <span class="number">1050.600</span></span><br><span class="line"><span class="number">116666</span>  <span class="number">2014</span><span class="number">-05</span><span class="number">-08</span>     First    KT<span class="number">-16480</span>  <span class="number">1799.970</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Отдельный кайф: значения для фильтров можно сохранить в&nbsp;переменной, а&nbsp;в&nbsp;запросе сослаться на&nbsp;нее с&nbsp;помощью символа @: <code>sales &gt; @sales_filter</code>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; sales_filter = <span class="number">1000</span></span><br><span class="line">&gt; ship_mode_filter = <span class="string">'First'</span></span><br><span class="line">&gt; orders.query(<span class="string">'sales &gt; @sales_filter &amp; ship_mode &gt; @ship_mode_filter'</span>)</span><br><span class="line">         order_date ship_mode customer_id     sales</span><br><span class="line">id                                                           </span><br><span class="line"><span class="number">101931</span>  <span class="number">2014</span><span class="number">-10</span><span class="number">-28</span>     First    TS<span class="number">-21370</span>  <span class="number">1252.602</span></span><br><span class="line"><span class="number">103100</span>  <span class="number">2014</span><span class="number">-12</span><span class="number">-20</span>     First    AB<span class="number">-10105</span>  <span class="number">1107.660</span></span><br><span class="line"><span class="number">106726</span>  <span class="number">2014</span><span class="number">-12</span><span class="number">-06</span>     First    RS<span class="number">-19765</span>  <span class="number">1261.330</span></span><br><span class="line"><span class="number">112158</span>  <span class="number">2014</span><span class="number">-12</span><span class="number">-02</span>     First    DP<span class="number">-13165</span>  <span class="number">1050.600</span></span><br><span class="line"><span class="number">116666</span>  <span class="number">2014</span><span class="number">-05</span><span class="number">-08</span>     First    KT<span class="number">-16480</span>  <span class="number">1799.970</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Разобравшись, как получать куски данных из&nbsp;датафрейма, перейдем к&nbsp;тому, как считать агрегированные метрики: количество заказов, суммарную выручку, средний чек, конверсию.</p>
<h2 id="Считаем-производные-метрики"><a href="#Считаем-производные-метрики" class="headerlink" title="Считаем производные метрики"></a>Считаем производные метрики</h2><p>Задача: посчитаем, сколько денег магазин заработал с&nbsp;помощью каждого класса доставки. Начнем с&nbsp;простого&nbsp;&mdash; просуммируем выручку со&nbsp;всех заказов. Для этого используем метод <code>.sum()</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; orders[<span class="string">'sales'</span>].sum()</span><br><span class="line"><span class="number">2297200.8603000003</span></span><br></pre></td></tr></table></figure>
<p>Добавим класс доставки. Перед суммированием сгруппируем данные с&nbsp;помощью метода <code>.groupby()</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; orders.groupby(<span class="string">'ship_mode'</span>)[<span class="string">'sales'</span>].sum()</span><br><span class="line">ship_mode              </span><br><span class="line">First      <span class="number">3.514284e+05</span></span><br><span class="line">Same Day   <span class="number">1.283631e+05</span></span><br><span class="line">Second     <span class="number">4.591936e+05</span></span><br><span class="line">Standard   <span class="number">1.358216e+06</span></span><br></pre></td></tr></table></figure>
<p><code>3.514284e+05</code>&nbsp;&mdash; научный формат вывода чисел. Означает 3.51 * 10<sup>5</sup>. Нам такая точность не&nbsp;нужна, поэтому можем сказать Pandas, чтобы округлял значения до&nbsp;сотых:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; pd.options.display.float_format = <span class="string">'&#123;:,.1f&#125;'</span>.format</span><br><span class="line">&gt; orders.groupby(<span class="string">'ship_mode'</span>)[<span class="string">'sales'</span>].sum()</span><br><span class="line">ship_mode            </span><br><span class="line">First       <span class="number">351</span>,<span class="number">428.4</span></span><br><span class="line">Same Day    <span class="number">128</span>,<span class="number">363.1</span></span><br><span class="line">Second      <span class="number">459</span>,<span class="number">193.6</span></span><br><span class="line">Standard  <span class="number">1</span>,<span class="number">358</span>,<span class="number">215.7</span></span><br></pre></td></tr></table></figure>
<p>Другое дело. Теперь видим сумму выручки по&nbsp;каждому классу доставки. По&nbsp;суммарной выручке неясно, становится лучше или хуже. Добавим разбивку по&nbsp;датам заказа:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; orders.groupby([<span class="string">'ship_mode'</span>, <span class="string">'order_date'</span>])[<span class="string">'sales'</span>].sum()</span><br><span class="line">ship_mode order_date        </span><br><span class="line">First     <span class="number">2014</span><span class="number">-01</span><span class="number">-06</span>    <span class="number">12.8</span></span><br><span class="line">          <span class="number">2014</span><span class="number">-01</span><span class="number">-11</span>     <span class="number">9.9</span></span><br><span class="line">          <span class="number">2014</span><span class="number">-01</span><span class="number">-14</span>    <span class="number">62.0</span></span><br><span class="line">          <span class="number">2014</span><span class="number">-01</span><span class="number">-15</span>   <span class="number">149.9</span></span><br><span class="line">          <span class="number">2014</span><span class="number">-01</span><span class="number">-19</span>   <span class="number">378.6</span></span><br><span class="line">          <span class="number">2014</span><span class="number">-01</span><span class="number">-26</span>   <span class="number">152.6</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Видно, что выручка прыгает ото дня ко&nbsp;дню: иногда 10&nbsp;долларов, а&nbsp;иногда 378. Интересно, это меняется количество заказов или средний чек? Добавим к&nbsp;выборке количество заказов. Для этого вместо <code>.sum()</code> используем метод <code>.agg()</code>, в&nbsp;который передадим список с&nbsp;названиями нужных функций.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; orders.groupby([<span class="string">'ship_mode'</span>, <span class="string">'order_date'</span>])[<span class="string">'sales'</span>].agg([<span class="string">'sum'</span>, <span class="string">'count'</span>])</span><br><span class="line">                       sum  count</span><br><span class="line">ship_mode order_date             </span><br><span class="line">First     <span class="number">2014</span><span class="number">-01</span><span class="number">-06</span>  <span class="number">12.8</span>      <span class="number">1</span></span><br><span class="line">          <span class="number">2014</span><span class="number">-01</span><span class="number">-11</span>   <span class="number">9.9</span>      <span class="number">1</span></span><br><span class="line">          <span class="number">2014</span><span class="number">-01</span><span class="number">-14</span>  <span class="number">62.0</span>      <span class="number">1</span></span><br><span class="line">          <span class="number">2014</span><span class="number">-01</span><span class="number">-15</span> <span class="number">149.9</span>      <span class="number">1</span></span><br><span class="line">          <span class="number">2014</span><span class="number">-01</span><span class="number">-19</span> <span class="number">378.6</span>      <span class="number">1</span></span><br><span class="line">          <span class="number">2014</span><span class="number">-01</span><span class="number">-26</span> <span class="number">152.6</span>      <span class="number">1</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Ого, получается, что это так прыгает средний чек. Интересно, а&nbsp;какой был самый удачный день? Чтобы узнать, отсортируем получившийся датафрейм: выведем 10 самых денежных дней по&nbsp;выручке:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; orders.groupby([<span class="string">'ship_mode'</span>, <span class="string">'order_date'</span>])[<span class="string">'sales'</span>].agg([<span class="string">'sum'</span>]).sort_values(by=<span class="string">'sum'</span>, ascending=<span class="literal">False</span>).head(<span class="number">10</span>)</span><br><span class="line">                          sum</span><br><span class="line">ship_mode order_date         </span><br><span class="line">Standard  <span class="number">2014</span><span class="number">-03</span><span class="number">-18</span> <span class="number">26</span>,<span class="number">908.4</span></span><br><span class="line">          <span class="number">2016</span><span class="number">-10</span><span class="number">-02</span> <span class="number">18</span>,<span class="number">398.2</span></span><br><span class="line">First     <span class="number">2017</span><span class="number">-03</span><span class="number">-23</span> <span class="number">14</span>,<span class="number">299.1</span></span><br><span class="line">Standard  <span class="number">2014</span><span class="number">-09</span><span class="number">-08</span> <span class="number">14</span>,<span class="number">060.4</span></span><br><span class="line">First     <span class="number">2017</span><span class="number">-10</span><span class="number">-22</span> <span class="number">13</span>,<span class="number">716.5</span></span><br><span class="line">Standard  <span class="number">2016</span><span class="number">-12</span><span class="number">-17</span> <span class="number">12</span>,<span class="number">185.1</span></span><br><span class="line">          <span class="number">2017</span><span class="number">-11</span><span class="number">-17</span> <span class="number">12</span>,<span class="number">112.5</span></span><br><span class="line">          <span class="number">2015</span><span class="number">-09</span><span class="number">-17</span> <span class="number">11</span>,<span class="number">467.6</span></span><br><span class="line">          <span class="number">2016</span><span class="number">-05</span><span class="number">-23</span> <span class="number">10</span>,<span class="number">561.0</span></span><br><span class="line">          <span class="number">2014</span><span class="number">-09</span><span class="number">-23</span> <span class="number">10</span>,<span class="number">478.6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Команда разрослась, и&nbsp;её теперь неудобно читать. Чтобы упростить, можно разбить её на&nbsp;несколько строк. В&nbsp;конце каждой строки ставим обратный слеш <code>\</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; orders \</span><br><span class="line"><span class="meta">... </span>.groupby([<span class="string">'ship_mode'</span>, <span class="string">'order_date'</span>])[<span class="string">'sales'</span>] \</span><br><span class="line"><span class="meta">... </span>.agg([<span class="string">'sum'</span>]) \</span><br><span class="line"><span class="meta">... </span>.sort_values(by=<span class="string">'sum'</span>, ascending=<span class="literal">False</span>) \</span><br><span class="line"><span class="meta">... </span>.head(<span class="number">10</span>)</span><br><span class="line">                          sum</span><br><span class="line">ship_mode order_date         </span><br><span class="line">Standard  <span class="number">2014</span><span class="number">-03</span><span class="number">-18</span> <span class="number">26</span>,<span class="number">908.4</span></span><br><span class="line">          <span class="number">2016</span><span class="number">-10</span><span class="number">-02</span> <span class="number">18</span>,<span class="number">398.2</span></span><br><span class="line">First     <span class="number">2017</span><span class="number">-03</span><span class="number">-23</span> <span class="number">14</span>,<span class="number">299.1</span></span><br><span class="line">Standard  <span class="number">2014</span><span class="number">-09</span><span class="number">-08</span> <span class="number">14</span>,<span class="number">060.4</span></span><br><span class="line">First     <span class="number">2017</span><span class="number">-10</span><span class="number">-22</span> <span class="number">13</span>,<span class="number">716.5</span></span><br><span class="line">Standard  <span class="number">2016</span><span class="number">-12</span><span class="number">-17</span> <span class="number">12</span>,<span class="number">185.1</span></span><br><span class="line">          <span class="number">2017</span><span class="number">-11</span><span class="number">-17</span> <span class="number">12</span>,<span class="number">112.5</span></span><br><span class="line">          <span class="number">2015</span><span class="number">-09</span><span class="number">-17</span> <span class="number">11</span>,<span class="number">467.6</span></span><br><span class="line">          <span class="number">2016</span><span class="number">-05</span><span class="number">-23</span> <span class="number">10</span>,<span class="number">561.0</span></span><br><span class="line">          <span class="number">2014</span><span class="number">-09</span><span class="number">-23</span> <span class="number">10</span>,<span class="number">478.6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>В самый удачный день&nbsp;&mdash; 18&nbsp;марта 2014 года&nbsp;&mdash; магазин заработал 27 тысяч долларов с&nbsp;помощью стандартного класса доставки. Интересно, откуда были клиенты, сделавшие эти заказы? Чтобы узнать, надо объединить данные о&nbsp;заказах с&nbsp;данными о&nbsp;клиентах.</p>
<h2 id="Объединяем-несколько-датафреймов"><a href="#Объединяем-несколько-датафреймов" class="headerlink" title="Объединяем несколько датафреймов"></a>Объединяем несколько датафреймов</h2><p>До&nbsp;сих пор мы&nbsp;смотрели только на&nbsp;таблицу с&nbsp;заказами. Но&nbsp;ведь у&nbsp;нас есть еще данные о&nbsp;клиентах интернет-магазина. Загрузим их&nbsp;в&nbsp;переменную <code>customers</code> и&nbsp;посмотрим, что они собой представляют:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; customers = pd.read_csv(<span class="string">'customers.csv'</span>, index=<span class="string">'id'</span>)</span><br><span class="line">&gt; customers.head()</span><br><span class="line">                     name    segment           state             city</span><br><span class="line">id                                                                   </span><br><span class="line">CG<span class="number">-12520</span>      Claire Gute   Consumer        Kentucky        Henderson</span><br><span class="line">DV<span class="number">-13045</span>  Darrin Van Huff  Corporate      California      Los Angeles</span><br><span class="line">SO<span class="number">-20335</span>   Sean O<span class="string">'Donnell   Consumer         Florida  Fort Lauderdale</span></span><br><span class="line"><span class="string">BH-11710  Brosina Hoffman   Consumer      California      Los Angeles</span></span><br><span class="line"><span class="string">AA-10480     Andrew Allen   Consumer  North Carolina          Concord</span></span><br></pre></td></tr></table></figure>
<p>Мы&nbsp;знаем тип клиента, место его проживания, его имя и&nbsp;имя контактного лица. У&nbsp;каждого клиента есть уникальный номер <code>id</code>. Этот&nbsp;же номер лежит в&nbsp;колонке <code>customer_id</code> таблицы <code>orders</code>. Значит мы&nbsp;можем найти, какие заказы сделал каждый клиент. Например, посмотрим, заказы пользователя <code>CG-12520</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; cust_filter = <span class="string">'CG-12520'</span></span><br><span class="line">&gt; orders.query(<span class="string">'customer_id == @cust_filter'</span>)</span><br><span class="line">                order_date ship_mode customer_id   sales</span><br><span class="line">id                                                          </span><br><span class="line">CA<span class="number">-2016</span><span class="number">-152156</span>  <span class="number">2016</span><span class="number">-11</span><span class="number">-08</span>    Second    CG<span class="number">-12520</span>  <span class="number">993.90</span></span><br><span class="line">CA<span class="number">-2017</span><span class="number">-164098</span>  <span class="number">2017</span><span class="number">-01</span><span class="number">-26</span>     First    CG<span class="number">-12520</span>   <span class="number">18.16</span></span><br><span class="line">US<span class="number">-2015</span><span class="number">-123918</span>  <span class="number">2015</span><span class="number">-10</span><span class="number">-15</span>  Same Day    CG<span class="number">-12520</span>  <span class="number">136.72</span></span><br></pre></td></tr></table></figure>
<p>Вернемся к&nbsp;задаче из&nbsp;предыдущего раздела: узнать, что за&nbsp;клиенты, которые сделали 18&nbsp;марта заказы со&nbsp;стандартной доставкой. Для этого объединим таблицы с&nbsp;клиентами и&nbsp;заказами. Датафреймы объединяют с&nbsp;помощью методов <code>.concat()</code>, <code>.merge()</code> и&nbsp;<code>.join()</code>. Все они делают одно и&nbsp;то&nbsp;же, но&nbsp;отличаются синтаксисом&nbsp;&mdash; на&nbsp;практике достаточно уметь пользоваться одним из&nbsp;них.</p>
<p>Покажу на&nbsp;примере <code>.merge()</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; new_df = pd.merge(orders, customers, how=<span class="string">'inner'</span>, left_on=<span class="string">'customer_id'</span>, right_index=<span class="literal">True</span>)</span><br><span class="line">&gt; new_df.columns</span><br><span class="line">Index([<span class="string">'order_date'</span>, <span class="string">'ship_mode'</span>, <span class="string">'customer_id'</span>, <span class="string">'sales'</span>, <span class="string">'name'</span>, <span class="string">'segment'</span>,</span><br><span class="line">       <span class="string">'state'</span>, <span class="string">'city'</span>],</span><br><span class="line">      dtype=<span class="string">'object'</span>)</span><br></pre></td></tr></table></figure>
<p>В&nbsp;<code>.merge()</code> я&nbsp;сначала указал названия датафреймов, которые хочу объединить. Затем уточнил, как именно их&nbsp;объединить и&nbsp;какие колонки использовать в&nbsp;качестве ключа.</p>
<p>Ключ&nbsp;&mdash; это колонка, связывающая оба датафрейма. В&nbsp;нашем случае&nbsp;&mdash; номер клиента. В&nbsp;таблице с&nbsp;заказами он&nbsp;в&nbsp;колонке <code>customer_id</code>, а&nbsp;таблице с&nbsp;клиентами&nbsp;&mdash; в&nbsp;индексе. Поэтому в&nbsp;команде мы&nbsp;пишем: <code>left_on=&#39;customer_id&#39;, right_index=True</code>.</p>
<h2 id="Решаем-задачу"><a href="#Решаем-задачу" class="headerlink" title="Решаем задачу"></a>Решаем задачу</h2><p>Закрепим полученный материал, решив задачу. Найдем 5 городов, принесших самую большую выручку в&nbsp;2016 году.</p>
<p>Для начала отфильтруем заказы из&nbsp;2016 года:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; orders_2016 = orders.query(<span class="string">"order_date &gt;= '2016-01-01' &amp; order_date &lt;= '2016-12-31'"</span>)</span><br><span class="line">&gt; orders_2016.head()</span><br><span class="line">       order_date ship_mode customer_id   sales</span><br><span class="line">id                                             </span><br><span class="line"><span class="number">100041</span> <span class="number">2016</span><span class="number">-11</span><span class="number">-20</span>  Standard    BF<span class="number">-10975</span>   <span class="number">328.5</span></span><br><span class="line"><span class="number">100083</span> <span class="number">2016</span><span class="number">-11</span><span class="number">-24</span>  Standard    CD<span class="number">-11980</span>    <span class="number">24.8</span></span><br><span class="line"><span class="number">100153</span> <span class="number">2016</span><span class="number">-12</span><span class="number">-13</span>  Standard    KH<span class="number">-16630</span>    <span class="number">63.9</span></span><br><span class="line"><span class="number">100244</span> <span class="number">2016</span><span class="number">-09</span><span class="number">-20</span>  Standard    GM<span class="number">-14695</span>   <span class="number">475.7</span></span><br><span class="line"><span class="number">100300</span> <span class="number">2016</span><span class="number">-06</span><span class="number">-24</span>    Second    MJ<span class="number">-17740</span> <span class="number">4</span>,<span class="number">823.1</span></span><br></pre></td></tr></table></figure>
<p>Город&nbsp;&mdash; это атрибут пользователей, а&nbsp;не&nbsp;заказов. Добавим информацию о&nbsp;пользователях:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; with_customers_2016 = pd.merge(customers, orders_2016, how=<span class="string">'inner'</span>, left_index=<span class="literal">True</span>, right_on=<span class="string">'customer_id'</span>)</span><br></pre></td></tr></table></figure>
<p>Cруппируем получившийся датафрейм по&nbsp;городам и&nbsp;посчитаем выручку:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; grouped_2016 = with_customers_2016.groupby(<span class="string">'city'</span>)[<span class="string">'sales'</span>].sum()</span><br><span class="line">&gt; grouped_2016.head()</span><br><span class="line">city</span><br><span class="line">Akron               <span class="number">1</span>,<span class="number">763.0</span></span><br><span class="line">Albuquerque           <span class="number">692.9</span></span><br><span class="line">Amarillo              <span class="number">197.2</span></span><br><span class="line">Arlington           <span class="number">5</span>,<span class="number">672.1</span></span><br><span class="line">Arlington Heights      <span class="number">14.1</span></span><br><span class="line">Name: sales, dtype: float64</span><br></pre></td></tr></table></figure>
<p>Отсортируем по&nbsp;убыванию продаж и&nbsp;оставим топ-5:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; top5 = grouped_2016.sort_values(ascending=<span class="literal">False</span>).head(<span class="number">5</span>)</span><br><span class="line">&gt; print(top5)</span><br><span class="line">city</span><br><span class="line">New York City   <span class="number">53</span>,<span class="number">094.1</span></span><br><span class="line">Philadelphia    <span class="number">39</span>,<span class="number">895.5</span></span><br><span class="line">Seattle         <span class="number">33</span>,<span class="number">955.5</span></span><br><span class="line">Los Angeles     <span class="number">33</span>,<span class="number">611.1</span></span><br><span class="line">San Francisco   <span class="number">27</span>,<span class="number">990.0</span></span><br><span class="line">Name: sales, dtype: float64</span><br></pre></td></tr></table></figure>
<p>Готово!</p>
<p>Попробуйте сами:</p>
<p>Возьмите данные о&nbsp;<a href="http://smysl.io/data/pandas/orders.csv">заказах</a> и&nbsp;<a href="http://smysl.io/data/pandas/customers.csv">покупателях</a> и&nbsp;посчитайте:</p>
<ol>
<li>Сколько заказов, отправлено первым классом за&nbsp;последние 5 лет?</li>
<li>Сколько в&nbsp;базе клиентов из&nbsp;Калифорнии?</li>
<li>Сколько заказов они сделали?</li>
<li>Постройте сводную таблицу средних чеков по&nbsp;всем штатам за&nbsp;каждый год.</li>
</ol>
<p>Через некоторое время выложу ответы <a href="https://t.me/kulichevskiy" target="_blank" rel="noopener">в&nbsp;Телеграме</a>. Подписывайтесь, чтобы не&nbsp;пропустить ответы и&nbsp;новые статьи.</p>
<p>До&nbsp;скорого!</p>
<p><em>Кстати, большое спасибо Александру Марфицину за&nbsp;то, что помог отредактировать статью.</em></p>
</div></div></div><div class="container container_margin"><div class="row"><div class="col-md-8 col-sm-12"><h1><a href="/blog/sql-views/">Упрощаем вложенные SQL-запросы с помощью представлений</a></h1><blockquote>
<p>Заметка для читателей <a href="http://smysl.io/?utm_source=blog&amp;utm_medium=content&amp;utm_campaign=sql-views">онлайн-курса по&nbsp;аналитике</a>, которые прошли хотя&nbsp;бы 5 уроков, уже знают, что такое SQL и&nbsp;умеют писать запросы к&nbsp;базе. Если SQL для вас в&nbsp;новинку, почитайте <a href="http://us2.campaign-archive2.com/?u=c36236612d4e515a821a0b7d9&amp;id=994ac3e2bf&amp;utm_source=facebook.com&amp;utm_medium=social&amp;utm_campaign=paru-mesyatsev-nazad-vc.ru-opublikoval-odi" target="_blank" rel="noopener">вводный урок про базы данных</a>.</p>
</blockquote>
<p>Результат любого SQL-запроса&nbsp;&mdash; это таблица. Значит, к&nbsp;ней можно направлять новые запросы, её можно джоинить с&nbsp;другими таблицами и&nbsp;использовать в&nbsp;фильтрах. Это позволяет реализовывать сложную логику.</p>
<p>Например, в&nbsp;седьмом уроке я&nbsp;рассказываю, как с&nbsp;помощью SQL достать данные для когортного анализа.</p>
<p>Начинаем с&nbsp;безобидного &laquo;давайте подсчитаем, сколько людей в&nbsp;каждой когорте&raquo;:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  reg_month <span class="keyword">AS</span> cohort_id,</span><br><span class="line">  <span class="keyword">count</span>(*)  <span class="keyword">AS</span> cohort_size</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  <span class="keyword">users</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>Потом считаем, сколько денег принесла каждая когорта:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  users.reg_month <span class="keyword">AS</span> cohort_id,</span><br><span class="line">  orders.month <span class="keyword">AS</span> <span class="keyword">month</span>,</span><br><span class="line">  <span class="keyword">sum</span>(orders.sum) <span class="keyword">AS</span> cohort_revenue</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  <span class="keyword">users</span> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> orders</span><br><span class="line">  <span class="keyword">ON</span> users.uid = orders.uid</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="number">1</span>, <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>Потом объединяем эти запросы, группируем и получаем вот такого монстра:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  rev.cohort_id <span class="keyword">AS</span> cohort_id,</span><br><span class="line">  rev.month <span class="keyword">AS</span> <span class="keyword">month</span>,</span><br><span class="line">  rev.month - rev.cohort_id <span class="keyword">AS</span> cohort_age,</span><br><span class="line">  rev.cohort_revenue  / size.cohort_size <span class="keyword">AS</span> LTV,</span><br><span class="line">  rev.cohort_revenue / size.costs * <span class="number">100</span> <span class="keyword">AS</span> ROI</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line">  <span class="keyword">SELECT</span></span><br><span class="line">    reg_month <span class="keyword">AS</span> cohort_id,</span><br><span class="line">    <span class="keyword">count</span>(*) <span class="keyword">AS</span> cohort_size</span><br><span class="line">  <span class="keyword">FROM</span></span><br><span class="line">    <span class="keyword">users</span></span><br><span class="line">  <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="number">1</span></span><br><span class="line">  ) <span class="keyword">AS</span> <span class="keyword">size</span></span><br><span class="line">  <span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">(</span><br><span class="line">  <span class="keyword">SELECT</span></span><br><span class="line">    users.reg_month <span class="keyword">AS</span> cohort_id,</span><br><span class="line">    orders.month <span class="keyword">AS</span> <span class="keyword">month</span>,</span><br><span class="line">    <span class="keyword">sum</span>(orders.sum) <span class="keyword">AS</span> cohort_revenue</span><br><span class="line">  <span class="keyword">FROM</span></span><br><span class="line">    <span class="keyword">users</span> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> orders</span><br><span class="line">    <span class="keyword">ON</span> users.uid = orders.uid</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">) <span class="keyword">AS</span> rev</span><br><span class="line"><span class="keyword">ON</span> size.cohort_id = rev.cohort_id</span><br></pre></td></tr></table></figure>
<p>Запрос правильный, но слишком громоздкий. Исправлять ошибки и вносить в&nbsp;него изменения — особый тип пытки.</p>
<p>Код можно упростить, если сохранить промежуточные результаты в виде представлений.</p>
<h2 id="Что-такое-представления-и-nbsp-как-они-работают"><a href="#Что-такое-представления-и-nbsp-как-они-работают" class="headerlink" title="Что такое представления и&nbsp;как они работают"></a>Что такое представления и&nbsp;как они работают</h2><p>Представления (ещё их называют «вью» от английского view) — это&nbsp;сохранённые запросы.</p>
<p>Внешне представление выглядит как ещё одна таблица. Если его использовать в&nbsp;запросе, база найдёт и&nbsp;подставит сохранённый код.</p>
<p>Например, мы сохранили запрос <code>SELECT * FROM some_table</code> в&nbsp;представление <code>my_view</code>. Теперь <code>my_view</code> можно использовать в&nbsp;запросах:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> …</span><br><span class="line"><span class="keyword">FROM</span> my_view</span><br><span class="line"><span class="keyword">WHERE</span> …</span><br></pre></td></tr></table></figure>
<p>Отправляем запрос — база находит и подставляет сохранённый код:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> …</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> some_table)</span><br><span class="line"><span class="keyword">WHERE</span> …</span><br></pre></td></tr></table></figure>
<p>Получаем результат, как при использовании вложенного селекта, но но более аккуратным кодом.</p>
<h2 id="Как-создать-представления"><a href="#Как-создать-представления" class="headerlink" title="Как создать представления"></a>Как создать представления</h2><p>В Бигквери нужно сначала выполнить запрос, затем нажать на кнопку Save View и выбрать название.</p>
<p>В других системах кнопки нет, но зато есть специальный запрос CREATE VIEW.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> my_view <span class="keyword">AS</span></span><br><span class="line">  <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> some_table</span><br></pre></td></tr></table></figure>
<p>Покажу подробней, как это работает в Бигквери, упрощу огромный запрос из начала статьи.</p>
<p>Сохраню первый запрос в представлении <code>cohort_sizes</code>:</p>
<img src="/img/sql-views/views1.gif" class="border-grey blog-content" title="width=600">
<p>Теперь могу просто запрашивать SELECT * FROM cohort_size, добавлять фильтры, группировки и сортировки.</p>
<img src="/img/sql-views/views2.gif" class="border-grey blog-content" title="width=600">
<p>Повторю процесс для второго запроса: отправлю, получу результат, сохраню представление <code>cohorts</code>.</p>
<img src="/img/sql-views/views3.gif" class="border-grey blog-content" title="width=600">
<p>Теперь заменю вложенные селекты в большом запросе на созданные представления. Смотрите, насколько аккуратней стал запрос:</p>
<p><strong>Было:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  rev.cohort_id <span class="keyword">AS</span> cohort_id,</span><br><span class="line">  rev.month <span class="keyword">AS</span> <span class="keyword">month</span>,</span><br><span class="line">  rev.month - rev.cohort_id <span class="keyword">AS</span> cohort_age,</span><br><span class="line">  rev.cohort_revenue  / size.cohort_size <span class="keyword">AS</span> LTV,</span><br><span class="line">  rev.cohort_revenue / size.costs * <span class="number">100</span> <span class="keyword">AS</span> ROI</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  reg_month <span class="keyword">AS</span> cohort_id,</span><br><span class="line">  <span class="keyword">count</span>(*) <span class="keyword">AS</span> cohort_size</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  <span class="keyword">users</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="number">1</span></span><br><span class="line">) <span class="keyword">AS</span> <span class="keyword">size</span></span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  users.reg_month <span class="keyword">AS</span> cohort_id,</span><br><span class="line">  orders.month <span class="keyword">AS</span> <span class="keyword">month</span>,</span><br><span class="line">  <span class="keyword">sum</span>(orders.sum) <span class="keyword">AS</span> cohort_revenue</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  <span class="keyword">users</span> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> orders</span><br><span class="line">  <span class="keyword">ON</span> users.uid = orders.uid</span><br><span class="line">  <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">) <span class="keyword">AS</span> rev</span><br><span class="line"><span class="keyword">ON</span> size.cohort_id = rev.cohort_id</span><br></pre></td></tr></table></figure>
<p><strong>Стало:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  rev.cohort_id <span class="keyword">AS</span> cohort_id,</span><br><span class="line">  rev.month <span class="keyword">AS</span> <span class="keyword">month</span>,</span><br><span class="line">  rev.month - rev.cohort_id <span class="keyword">AS</span> cohort_age,</span><br><span class="line">  rev.cohort_revenue  / size.cohort_size <span class="keyword">AS</span> LTV,</span><br><span class="line">  rev.cohort_revenue / size.costs * <span class="number">100</span> <span class="keyword">AS</span> ROI</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  cohort_sizes <span class="keyword">AS</span> <span class="keyword">size</span></span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">  cohorts <span class="keyword">AS</span> rev</span><br><span class="line"><span class="keyword">ON</span> size.cohort_id = rev.cohort_id</span><br></pre></td></tr></table></figure>
<p>На этом всё. Успехов.</p>
</div></div></div></div><footer id="bottom-outer" role="footer"><div id="bottom-inner"><div class="container"><div class="row"><div class="col-md-8 col-sm-12"><p><span>&copy; Алексей Куличевский 2017–2019</span></p></div></div></div></div></footer></div></div></div></div><script src="/lib/jquery-3.2.1.min.js"></script><script src="/js/glow.js"></script><script src="/js/app.js"></script><script src="/js/payment-form.js"> </script></body>