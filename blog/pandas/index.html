<!DOCTYPE html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Anonymous+Pro|PT+Mono"><link rel="stylesheet" href="/fonts/font-awesome-4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="/css/glow.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/lessons-pointer.css"><link rel="stylesheet" href="/css/social-likes_birman.css"><link rel="stylesheet" href="/css/blog.css"><link rel="stylesheet" href="/css/landing.css"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="icon" href="http://ono38scfe.bkt.clouddn.com/favicon_tree.ico"><link rel="icon" type="image/png" sizes="16x16" href="undefined"><title>Шпаргалка по Пандасу</title></head><body><div class="blog"><div class="container"><div class="row"><div class="col-md-8 col-sm-12"><div class="avatar"><span><a href="/"><img src="https://s.gravatar.com/avatar/e574dc154e694d72dc40e1dc9be17c32?s=80" width="40px" height="40px"></a></span><span class="author_name"> <a href="/">Алексей Куличевский</a><span style="font-family: graphik-regular;">Блог · <a class="header" href="https://t.me/kulichevskiy" target="_blank">Телеграм</a> · <a class="header" href="/courses/data-1">Курс</a></span></span></div></div></div></div><div class="container container_margin"><div class="row"><div class="col-md-8 col-sm-12"><h1>Шпаргалка по Пандасу</h1><blockquote>
<p>Эта шпаргалка для студентов курса Digital Rockstar про анализ данных с помощью пайтона. Записаться на курс вот тут: <a href="https://digitalgod.be/rockstar" target="_blank" rel="noopener">https://digitalgod.be/rockstar</a></p>
</blockquote>
<p>Пандас добавлет в пайтон новые структуры данных — серии и датафреймы. Они упрощают жизнь аналитикам: где раньше надо было писать 10 строк кода, теперь достаточно одной.</p>
<p>Например, чтобы продчитать данные из csv, в ванильном пайтоне надо сначала самостоятельно решить, как будете хранить данные, затем открыть файл, прочитать его построчно, отделить значения друг от друга, очистить данные от специальных символов, а потом еще и перевести в нужные форматы вручную.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'file.csv'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    content = f.readlines()</span><br><span class="line">    content = [x.split(<span class="string">','</span>).replace(<span class="string">'\n'</span>,<span class="string">''</span>) <span class="keyword">for</span> x <span class="keyword">in</span> content]</span><br></pre></td></tr></table></figure>
<p>В пандасе всё проще, то во-первых, не нужно думать о том, как будут хранится данные. Они будут хранится в датафрейме. А во-вторых, нужно будет написать только одну команду:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = pd.read_csv(<span class="string">'file.csv'</span>)</span><br></pre></td></tr></table></figure>
<p>Расскажу подробнее о сериях и датафреймах</p>
<h2 id="Серии"><a href="#Серии" class="headerlink" title="Серии"></a>Серии</h2><p>Серии редко используют отдельно, но они — кирпичики, из которых состоят датафреймы. Поэтому если поймета, как они работают, дальше всё будет очень просто.</p>
<p>Серии — это одномерные массивы данных. Они очень похожи на списки, но отличаются по поведению. Например, операции применяются к списку целиком, а в сериях по-элементно.</p>
<p>То есть если список умножить на 2, получите тот же список, повторенный 2 раза.  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; vector = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&gt; vector * <span class="number">2</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>А если умножить серию, получите серию, в которой каждый элемент умножен на 2.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">&gt; series = pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">&gt; series * <span class="number">2</span></span><br><span class="line"><span class="number">0</span>    <span class="number">2</span></span><br><span class="line"><span class="number">1</span>    <span class="number">4</span></span><br><span class="line"><span class="number">2</span>    <span class="number">6</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>Обратите внимание на первый столбик вывода. Это индекс, в котором хранятся адреса каждого элемента серии. Эти элементы потом можно получать, постучавшись по нужному адресу.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; series = pd.Series([<span class="string">'foo'</span>, <span class="string">'bar'</span>])</span><br><span class="line">&gt; series[<span class="number">0</span>]</span><br><span class="line"><span class="string">'foo'</span></span><br></pre></td></tr></table></figure>
<p>Еще одно отличие серий от списков — в качестве индексов можно использовать произвольные значения. Это помогает придать данным больше наглядности. Например, представим, что мы анализируем помесячные продажи. Используем в качестве индексов названия месяцев. Значениями будет выручка.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; months = [<span class="string">'jan'</span>, <span class="string">'feb'</span>, <span class="string">'mar'</span>, <span class="string">'apr'</span>]</span><br><span class="line">&gt; sales = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>]</span><br><span class="line">&gt; data = pd.Series(data=sales, index=months)</span><br><span class="line">&gt; data</span><br><span class="line">jan    <span class="number">100</span></span><br><span class="line">feb    <span class="number">200</span></span><br><span class="line">mar    <span class="number">300</span></span><br><span class="line">apr    <span class="number">400</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>Теперь можем получать значения каждого месяца.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; data[<span class="string">'feb'</span>]</span><br><span class="line"><span class="number">200</span></span><br></pre></td></tr></table></figure>
<p>Так как серии — одномерный массив данных, в них удоно хранить измерения по одному. На практике удобнее группировать данные вместе. Например, если мы анализируем помесячные продажи, полезно видеть не только выручку, но и количество проданных товаров, количество новых клиентов и средний чек. Для этого отлично подходят датафреймы.</p>
<h2 id="Датафреймы"><a href="#Датафреймы" class="headerlink" title="Датафреймы"></a>Датафреймы</h2><p>Датафреймы — это таблицы. У их есть строки, колонки и ячейки.</p>
<p>Технически колонки датафреймов — это серии. И, так как данные в колонках обычно описывают одни и те же объекты (например, продажи за месяц), то все колонки делят один и тот же индекс.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; months = [<span class="string">'jan'</span>, <span class="string">'feb'</span>, <span class="string">'mar'</span>, <span class="string">'apr'</span>]</span><br><span class="line">&gt; sales = &#123;</span><br><span class="line"><span class="meta">... </span>   <span class="string">'revenue'</span>:     [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>],</span><br><span class="line"><span class="meta">... </span>   <span class="string">'items_sold'</span>:  [<span class="number">23</span>, <span class="number">43</span>, <span class="number">55</span>, <span class="number">65</span>],</span><br><span class="line"><span class="meta">... </span>   <span class="string">'new_clients'</span>: [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]</span><br><span class="line">...&#125;</span><br><span class="line">&gt; sales_df = pd.DataFrame(data=sales, index=months)</span><br><span class="line">&gt; sales_df</span><br><span class="line">     revenue  items_sold  new_clients</span><br><span class="line">jan      <span class="number">100</span>          <span class="number">23</span>           <span class="number">10</span></span><br><span class="line">feb      <span class="number">200</span>          <span class="number">43</span>           <span class="number">20</span></span><br><span class="line">mar      <span class="number">300</span>          <span class="number">55</span>           <span class="number">30</span></span><br><span class="line">apr      <span class="number">400</span>          <span class="number">65</span>           <span class="number">40</span></span><br></pre></td></tr></table></figure>
<p>Расскажу подробнее о том, как создавать датафреймы и загружать в них данные.</p>
<h2 id="Создаем-датафреймы-и-загружаем-в-них-данные"><a href="#Создаем-датафреймы-и-загружаем-в-них-данные" class="headerlink" title="Создаем датафреймы и загружаем в них данные"></a>Создаем датафреймы и загружаем в них данные</h2><p>Бывает, что мы не знаем, что собой представляют данные, и не можем задать структуру заранее. Тогда удобно создать пустой датафрейм и наполнить его данными позже.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; df = pd.DataFrame()</span><br></pre></td></tr></table></figure>
<p>Выше я показывал пример, как превратить список словарей в датафрейм и загрузить индекс. Используем ту же команду, но теперь передаем в неё параметры data и index.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; df = pd.DataFrame(sales_df = pd.DataFrame(data=sales, index=months))</span><br></pre></td></tr></table></figure>
<p>Бывает, что в некоторых записях не хватает данных. Например, посмотрите на этот список. В нём продажи, разбитые по разным товарным категориям. В первом месяце мы продали машины, компьютеры и программное обеспечение. Во втором мышин нет, зато появились велосипеды. В третьем снова появились машины, но велосипеды исчезли обратно.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; goods_sold = [</span><br><span class="line"><span class="meta">... </span>    &#123;<span class="string">'computers'</span>: <span class="number">10</span>, <span class="string">'cars'</span>: <span class="number">1</span>, <span class="string">'soft'</span>: <span class="number">3</span>&#125;,</span><br><span class="line"><span class="meta">... </span>    &#123;<span class="string">'computers'</span>: <span class="number">4</span>, <span class="string">'soft'</span>: <span class="number">5</span>, <span class="string">'bicycles'</span>: <span class="number">1</span>&#125;,</span><br><span class="line"><span class="meta">... </span>    &#123;<span class="string">'computers'</span>: <span class="number">6</span>, <span class="string">'cars'</span>: <span class="number">2</span>, <span class="string">'soft'</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">... </span>]</span><br></pre></td></tr></table></figure>
<p>Если загрузить данные в датафрейм, Пандас создаст колонки для всех товарных категорий и, где это возможно, заполнит их данными.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; pd.DataFrame(goods_sold)</span><br><span class="line">   bicycles  cars  computers  soft</span><br><span class="line"><span class="number">0</span>       NaN   <span class="number">1.0</span>         <span class="number">10</span>     <span class="number">3</span></span><br><span class="line"><span class="number">1</span>       <span class="number">1.0</span>   NaN          <span class="number">4</span>     <span class="number">5</span></span><br><span class="line"><span class="number">2</span>       NaN   <span class="number">2.0</span>          <span class="number">6</span>     <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>Обратите внимание, продажи велосипедов в первом и третьем месяце равны NaN. Расшифровывается, как Not a Number. Так пандас помечает отсутствующие значения.</p>
<p>Теперь разберем, как загружать данные из файлов. Чаще всего я данные хранятся в экселевских таблицах или текстовых файлах csv, tsv.</p>
<p>Экселевские таблицы читаются с помощью команды <code>pd.read_excel()</code>. Параметрами нужно передать адрес файла на компьютере и название листа, который нужно прочитать. Команда работает, как для xls, так и для xlsx.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; pd.read_excel(<span class="string">'file.xlsx'</span>, sheet_name=<span class="string">'Sheet1'</span>)</span><br></pre></td></tr></table></figure>
<p>Csv и tsv — это текстовые файлы, в которых данные отделены друг от друга запятыми или табуляцией.</p>
<pre><code class="python"># CSV
month,customers,sales
feb,10,200

#TSV
month\tcustomers\tsales
feb\t10\t200
</code></pre>
<p>Оба читаются с помощью команды <code>.read_csv()</code>, символ табуляции передается параметром.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; pd.read_csv(<span class="string">'file.csv'</span>)</span><br><span class="line">&gt; pd.read_csv(<span class="string">'file.tsv'</span>, sep=<span class="string">'\t'</span>)</span><br></pre></td></tr></table></figure>
<p>Иногда бывает удобно уже на этапе загрузки указать, какой столбец в данных будет индексом. Например, если  мы загружаем таблицу с заказами, и у каждого заказа есть свой уникальный номер, было бы классно делать запросы типа <code>df[order_id]</code>. Для этого добавим в команду параметр <code>index_col</code> и назначим ему название нужно колонки.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; pd.read_csv(<span class="string">'file.csv'</span>, index_col=<span class="string">'id'</span>)</span><br></pre></td></tr></table></figure>
<p>После того, как мы загрузили данные в датафрейм, особенно, если это незнакомые нам данные, хорошо бы их исследовать. Расскажу подробнее, как это сделать.</p>
<h2 id="Исследуем-загруженные-данные"><a href="#Исследуем-загруженные-данные" class="headerlink" title="Исследуем загруженные данные"></a>Исследуем загруженные данные</h2><p>Представим, что мы загрузили файл с продажами интернет-магазина в переменную <code>df</code>. Раз загружаем заказы, укажем, что колонка <code>id</code> пойдет в индекс.<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; df = pd.read_csv(<span class="string">'orders.csv'</span>, index_col=<span class="string">'id'</span>)</span><br></pre></td></tr></table></figure></p>
<p>Расскажу о четырех аттрибутах, которые есть у любого датафрейма: <code>.shape</code>, <code>.columns</code>, <code>.index</code> и <code>.dtypes</code>.</p>
<p><code>.shape</code> показывает, сколько в датафрейме строк и колонок. Он возращает пару значений (n_rows, n_columns). Сначала идут строки, потом колонки.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; df.shape</span><br><span class="line">(<span class="number">5009</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>В датафрейме 5009 строк и 5 колонок. С помощью <code>.columns</code> узнаем, как называются эти колонки.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; df.columns</span><br><span class="line">Index([<span class="string">'order_date'</span>, <span class="string">'ship_date'</span>, <span class="string">'ship_mode'</span>, <span class="string">'customer_id'</span>, <span class="string">'sales'</span>], dtype=<span class="string">'object'</span>)</span><br></pre></td></tr></table></figure>
<p>С помощью <code>.dtypes</code> узнаем типы данных, находящихся в каждой колонке.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; df.dtypes</span><br><span class="line">order_date      object</span><br><span class="line">ship_date       object</span><br><span class="line">ship_mode       object</span><br><span class="line">customer_id     object</span><br><span class="line">sales          float64</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure>
<p>Тип <code>object</code> — это текст. <code>float64</code> – это дробное число типа 3,14.</p>
<p>Посмотрим, как называются строки с помощью аттрибута <code>.index</code>.<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; df.index</span><br><span class="line">Index([<span class="string">'CA-2014-100006'</span>, <span class="string">'CA-2014-100090'</span>, <span class="string">'CA-2014-100293'</span>, <span class="string">'CA-2014-100328'</span>,</span><br><span class="line">       <span class="string">'CA-2014-100363'</span>, <span class="string">'CA-2014-100391'</span>, <span class="string">'CA-2014-100678'</span>, <span class="string">'CA-2014-100706'</span>,</span><br><span class="line">       <span class="string">'CA-2014-100762'</span>, <span class="string">'CA-2014-100860'</span>,</span><br><span class="line">       ...</span><br><span class="line">       <span class="string">'US-2017-167570'</span>, <span class="string">'US-2017-167920'</span>, <span class="string">'US-2017-168116'</span>, <span class="string">'US-2017-168613'</span>,</span><br><span class="line">       <span class="string">'US-2017-168690'</span>, <span class="string">'US-2017-168802'</span>, <span class="string">'US-2017-169320'</span>, <span class="string">'US-2017-169488'</span>,</span><br><span class="line">       <span class="string">'US-2017-169502'</span>, <span class="string">'US-2017-169551'</span>],</span><br><span class="line">      dtype=<span class="string">'object'</span>, name=<span class="string">'id'</span>, length=<span class="number">5009</span>)</span><br></pre></td></tr></table></figure></p>
<p>Ожидаемо, в индексе датафрейма номера заказов.</p>
<p>В колонке <code>sales</code> хранится стоимость каждого проданного товара. Если мы заходим узнать, разброс значений, среднюю стоимость и медиану, используем метод <code>.describe()</code>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; df.describe()</span><br><span class="line">         sales</span><br><span class="line">count   <span class="number">5009.0</span></span><br><span class="line">mean     <span class="number">458.6</span></span><br><span class="line">std      <span class="number">954.7</span></span><br><span class="line">min        <span class="number">0.6</span></span><br><span class="line"><span class="number">25</span>%       <span class="number">37.6</span></span><br><span class="line"><span class="number">50</span>%      <span class="number">152.0</span></span><br><span class="line"><span class="number">75</span>%      <span class="number">512.1</span></span><br><span class="line">max    <span class="number">23661.2</span></span><br></pre></td></tr></table></figure>
<p>Наконец, чтобы посмотреть на несколько примеров записей датафрейма, используем команды <code>.head()</code> и <code>.sample()</code>. Первая возвращает 6 записей из начала датафрейма. Вторая — 6 случайных записей.  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; df.head()</span><br><span class="line">                order_date   ship_date       ship_mode customer_id    sales</span><br><span class="line">id                                                                         </span><br><span class="line">CA<span class="number">-2014</span><span class="number">-100006</span>  <span class="number">2014</span><span class="number">-09</span><span class="number">-07</span>  <span class="number">2014</span><span class="number">-09</span><span class="number">-13</span>  Standard Class    DK<span class="number">-13375</span>  <span class="number">377.970</span></span><br><span class="line">CA<span class="number">-2014</span><span class="number">-100090</span>  <span class="number">2014</span><span class="number">-07</span><span class="number">-08</span>  <span class="number">2014</span><span class="number">-07</span><span class="number">-12</span>  Standard Class    EB<span class="number">-13705</span>  <span class="number">699.192</span></span><br><span class="line">CA<span class="number">-2014</span><span class="number">-100293</span>  <span class="number">2014</span><span class="number">-03</span><span class="number">-14</span>  <span class="number">2014</span><span class="number">-03</span><span class="number">-18</span>  Standard Class    NF<span class="number">-18475</span>   <span class="number">91.056</span></span><br><span class="line">CA<span class="number">-2014</span><span class="number">-100328</span>  <span class="number">2014</span><span class="number">-01</span><span class="number">-28</span>  <span class="number">2014</span><span class="number">-02</span><span class="number">-03</span>  Standard Class    JC<span class="number">-15340</span>    <span class="number">3.928</span></span><br><span class="line">CA<span class="number">-2014</span><span class="number">-100363</span>  <span class="number">2014</span><span class="number">-04</span><span class="number">-08</span>  <span class="number">2014</span><span class="number">-04</span><span class="number">-15</span>  Standard Class    JM<span class="number">-15655</span>   <span class="number">21.376</span></span><br></pre></td></tr></table></figure>
<p>Получив первое представление о датафрейме, теперь обсудим, как доставать из него данные.</p>
<h2 id="Получаем-данные"><a href="#Получаем-данные" class="headerlink" title="Получаем данные"></a>Получаем данные</h2><p>Начнем с того, как выбрать нужные колонки. </p>
</div></div></div><footer id="bottom-outer" role="footer"><div id="bottom-inner"><div class="container"><div class="row"><div class="col-md-8 col-sm-12"><p><span>&copy; Алексей Куличевский 2017–2019</span></p></div></div></div></div></footer></div><script src="/lib/jquery-3.2.1.min.js"></script><script src="/js/glow.js"></script><script src="/js/app.js"></script><script src="/js/payment-form.js"> </script></body>