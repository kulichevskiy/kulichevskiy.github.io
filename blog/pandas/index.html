<!DOCTYPE html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta property="og:image" content="http://smysl.io/img/pandas/og-fb.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Anonymous+Pro|PT+Mono"><link rel="stylesheet" href="/fonts/font-awesome-4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="/css/glow.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/lessons-pointer.css"><link rel="stylesheet" href="/css/social-likes_birman.css"><link rel="stylesheet" href="/css/blog.css"><link rel="stylesheet" href="/css/landing.css"><link rel="apple-touch-icon-precomposed" sizes="57x57" href="img/favicons/apple-touch-icon-57x57.png"><link rel="apple-touch-icon-precomposed" sizes="114x114" href="img/favicons/apple-touch-icon-114x114.png"><link rel="apple-touch-icon-precomposed" sizes="72x72" href="img/favicons/apple-touch-icon-72x72.png"><link rel="apple-touch-icon-precomposed" sizes="144x144" href="img/favicons/apple-touch-icon-144x144.png"><link rel="apple-touch-icon-precomposed" sizes="60x60" href="img/favicons/apple-touch-icon-60x60.png"><link rel="apple-touch-icon-precomposed" sizes="120x120" href="img/favicons/apple-touch-icon-120x120.png"><link rel="apple-touch-icon-precomposed" sizes="76x76" href="img/favicons/apple-touch-icon-76x76.png"><link rel="apple-touch-icon-precomposed" sizes="152x152" href="img/favicons/apple-touch-icon-152x152.png"><link rel="icon" type="image/png" href="img/favicons/favicon-196x196.png" sizes="196x196"><link rel="icon" type="image/png" href="img/favicons/favicon-96x96.png" sizes="96x96"><link rel="icon" type="image/png" href="img/favicons/favicon-32x32.png" sizes="32x32"><link rel="icon" type="image/png" href="img/favicons/favicon-16x16.png" sizes="16x16"><link rel="icon" type="image/png" href="img/favicons/favicon-128.png" sizes="128x128"><meta name="application-name" content=" "><meta name="msapplication-TileColor" content="#FFFFFF"><meta name="msapplication-TileImage" content="img/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="mg/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="img/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="img/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="img/favicons/mstile-310x310.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="jS-UOFLu8isjqw3UjLkGEP-fD-tG7w7cAMLIeSepC7M"><meta name="yandex-verification" content="3365363b8d7940a9"><link rel="icon" href="http://ono38scfe.bkt.clouddn.com/favicon_tree.ico"><link rel="icon" type="image/png" sizes="16x16" href="undefined"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-MS47VNR');</script><title>Аналитикам: большая шпаргалка по Pandas</title></head><body><!-- - Google Tag Manager (noscript)--><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-MS47VNR" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><!-- - End Google Tag Manager (noscript)--><div class="blog"><div class="container"><div class="row"><div class="col-md-8 col-sm-12"><div class="avatar"><span><a href="/"><img src="https://s.gravatar.com/avatar/e574dc154e694d72dc40e1dc9be17c32?s=80" width="40px" height="40px"></a></span><span class="author_name"> <a href="/">Алексей Куличевский</a><span style="font-family: graphik-regular;">Блог · <a class="header" href="https://t.me/kulichevskiy" target="_blank">Телеграм</a> · <a class="header" href="/courses/data-1">Курс</a></span></span></div></div></div></div><div class="container container_margin"><div class="row"><div class="col-md-8 col-sm-12"><h1>Аналитикам: большая шпаргалка по Pandas</h1><blockquote>
<p>Привет. Я&nbsp;задумывал эту заметку для студентов курса <a href="a href=&quot;https://digitalgod.be/rockstar&quot;&gt;https://digitalgod.be/rockstar&lt;/a">Digital Rockstar</a>, на&nbsp;котором мы&nbsp;учим маркетологов автоматизировать свою работу с&nbsp;помощью программирования, но&nbsp;решил поделиться шпаргалкой по&nbsp;Pandas со&nbsp;всеми. Я&nbsp;ожидаю, что читатель умеет писать код на&nbsp;Python хотя&nbsp;бы на&nbsp;минимальном уровне, знает, что такое списки, словари, циклы и&nbsp;функции.</p>
</blockquote>
<ol>
<li><a href="#Что-такое-Pandas-и-зачем-он-нужен">Что такое Pandas и&nbsp;зачем он&nbsp;нужен</a></li>
<li><a href="#Структуры-данных">Структуры данных: серии и&nbsp;датафреймы</a></li>
<li><a href="#Создаем-датафреймы-и-загружаем-в-них-данные">Создаем датафреймы и&nbsp;загружаем в&nbsp;них данные</a></li>
<li><a href="#Исследуем-загруженные-данные">Исследуем загруженные данные</a></li>
<li><a href="#Получаем-данные-из-датафреймов">Получаем данные из&nbsp;датафреймов</a></li>
<li><a href="#Считаем-производные-метрики">Считаем производные метрики</a></li>
<li><a href="#Объединяем-несколько-датафреймов">Объединяем несколько датафреймов</a></li>
<li><a href="#Решаем-задачу">Решаем задачу</a></li>
</ol>
<h2 id="Что-такое-Pandas-и-nbsp-зачем-он-nbsp-нужен"><a href="#Что-такое-Pandas-и-nbsp-зачем-он-nbsp-нужен" class="headerlink" title="Что такое Pandas и&nbsp;зачем он&nbsp;нужен"></a>Что такое Pandas и&nbsp;зачем он&nbsp;нужен</h2><p>Pandas&nbsp;&mdash; это библиотека для работы с&nbsp;данными на&nbsp;Python. Она упрощает жизнь аналитикам: где раньше использовалось 10 строк кода теперь хватит одной.</p>
<p>Например, чтобы прочитать данные из&nbsp;csv, в&nbsp;стандартном Python надо сначала решить, как хранить данные, затем открыть файл, прочитать его построчно, отделить значения друг от&nbsp;друга и&nbsp;очистить данные от&nbsp;специальных символов.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">with</span> open(<span class="string">'file.csv'</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">... </span>   content = f.readlines()</span><br><span class="line"><span class="meta">... </span>   content = [x.split(<span class="string">','</span>).replace(<span class="string">'\n'</span>,<span class="string">''</span>) <span class="keyword">for</span> x <span class="keyword">in</span> content]</span><br></pre></td></tr></table></figure>
<p>В&nbsp;Pandas всё проще. Во-первых, не&nbsp;нужно думать, как будут храниться данные&nbsp;&mdash; они лежат в&nbsp;датафрейме. Во-вторых, достаточно написать одну команду:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; data = pd.read_csv(<span class="string">'file.csv'</span>)</span><br></pre></td></tr></table></figure>
<p>Pandas добавляет в&nbsp;Python новые структуры данных&nbsp;&mdash; серии и&nbsp;датафреймы. Расскажу, что это такое.</p>
<h2 id="Структуры-данных-серии-и-nbsp-датафреймы"><a href="#Структуры-данных-серии-и-nbsp-датафреймы" class="headerlink" title="Структуры данных: серии и&nbsp;датафреймы"></a>Структуры данных: серии и&nbsp;датафреймы</h2><p>Серии&nbsp;&mdash; одномерные массивы данных. Они очень похожи на&nbsp;списки, но&nbsp;отличаются по&nbsp;поведению&nbsp;&mdash; например, операции применяются к&nbsp;списку целиком, а&nbsp;в&nbsp;сериях&nbsp;&mdash; поэлементно.</p>
<p>То&nbsp;есть, если список умножить на&nbsp;2, получите тот&nbsp;же список, повторенный 2 раза.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; vector = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&gt; vector * <span class="number">2</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>А если умножить серию, ее длина не изменится, а вот элементы удвоятся.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">&gt; series = pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">&gt; series * <span class="number">2</span></span><br><span class="line"><span class="number">0</span>    <span class="number">2</span></span><br><span class="line"><span class="number">1</span>    <span class="number">4</span></span><br><span class="line"><span class="number">2</span>    <span class="number">6</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>Обратите внимание на&nbsp;первый столбик вывода. Это индекс, в&nbsp;котором хранятся адреса каждого элемента серии. Каждый элемент потом можно получать, обратившись по&nbsp;нужному адресу.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; series = pd.Series([<span class="string">'foo'</span>, <span class="string">'bar'</span>])</span><br><span class="line">&gt; series[<span class="number">0</span>]</span><br><span class="line"><span class="string">'foo'</span></span><br></pre></td></tr></table></figure>
<p>Еще одно отличие серий от&nbsp;списков&nbsp;&mdash; в&nbsp;качестве индексов можно использовать произвольные значения, это делает данные нагляднее. Представим, что мы&nbsp;анализируем помесячные продажи. Используем в&nbsp;качестве индексов названия месяцев, значениями будет выручка:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; months = [<span class="string">'jan'</span>, <span class="string">'feb'</span>, <span class="string">'mar'</span>, <span class="string">'apr'</span>]</span><br><span class="line">&gt; sales = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>]</span><br><span class="line">&gt; data = pd.Series(data=sales, index=months)</span><br><span class="line">&gt; data</span><br><span class="line">jan    <span class="number">100</span></span><br><span class="line">feb    <span class="number">200</span></span><br><span class="line">mar    <span class="number">300</span></span><br><span class="line">apr    <span class="number">400</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>Теперь можем получать значения каждого месяца:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; data[<span class="string">'feb'</span>]</span><br><span class="line"><span class="number">200</span></span><br></pre></td></tr></table></figure>
<p>Так как серии&nbsp;&mdash; одномерный массив данных, в&nbsp;них удобно хранить измерения по&nbsp;одному. На&nbsp;практике удобнее группировать данные вместе. Например, если мы&nbsp;анализируем помесячные продажи, полезно видеть не&nbsp;только выручку, но&nbsp;и&nbsp;количество проданных товаров, количество новых клиентов и&nbsp;средний чек. Для этого отлично подходят датафреймы.</p>
<p>Датафреймы&nbsp;&mdash; это таблицы. У&nbsp;их&nbsp;есть строки, колонки и&nbsp;ячейки.</p>
<p>Технически, колонки датафреймов&nbsp;&mdash; это серии. Поскольку в&nbsp;колонках обычно описывают одни и&nbsp;те&nbsp;же объекты, то&nbsp;все колонки делят один и&nbsp;тот&nbsp;же индекс:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; months = [<span class="string">'jan'</span>, <span class="string">'feb'</span>, <span class="string">'mar'</span>, <span class="string">'apr'</span>]</span><br><span class="line">&gt; sales = &#123;</span><br><span class="line"><span class="meta">... </span>   <span class="string">'revenue'</span>:     [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>],</span><br><span class="line"><span class="meta">... </span>   <span class="string">'items_sold'</span>:  [<span class="number">23</span>, <span class="number">43</span>, <span class="number">55</span>, <span class="number">65</span>],</span><br><span class="line"><span class="meta">... </span>   <span class="string">'new_clients'</span>: [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]</span><br><span class="line">...&#125;</span><br><span class="line">&gt; sales_df = pd.DataFrame(data=sales, index=months)</span><br><span class="line">&gt; sales_df</span><br><span class="line">     revenue  items_sold  new_clients</span><br><span class="line">jan      <span class="number">100</span>          <span class="number">23</span>           <span class="number">10</span></span><br><span class="line">feb      <span class="number">200</span>          <span class="number">43</span>           <span class="number">20</span></span><br><span class="line">mar      <span class="number">300</span>          <span class="number">55</span>           <span class="number">30</span></span><br><span class="line">apr      <span class="number">400</span>          <span class="number">65</span>           <span class="number">40</span></span><br></pre></td></tr></table></figure>
<p>Объясню, как создавать датафреймы и&nbsp;загружать в&nbsp;них данные.</p>
<h2 id="Создаем-датафреймы-и-nbsp-загружаем-данные"><a href="#Создаем-датафреймы-и-nbsp-загружаем-данные" class="headerlink" title="Создаем датафреймы и&nbsp;загружаем данные"></a>Создаем датафреймы и&nbsp;загружаем данные</h2><p>Бывает, что мы&nbsp;не&nbsp;знаем, что собой представляют данные, и&nbsp;не&nbsp;можем задать структуру заранее. Тогда удобно создать пустой датафрейм и&nbsp;позже наполнить его данными.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; df = pd.DataFrame()</span><br></pre></td></tr></table></figure>
<p>А&nbsp;иногда данные уже есть, но&nbsp;хранятся в&nbsp;переменной из&nbsp;стандартного Python, например, в&nbsp;словаре. Чтобы получить датафрейм, эту переменную передаем в&nbsp;ту&nbsp;же команду:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; df = pd.DataFrame(data=sales, index=months))</span><br></pre></td></tr></table></figure>
<p>Случается, что в&nbsp;некоторых записях не&nbsp;хватает данных. Например, посмотрите на&nbsp;список <code>goods_sold</code>&nbsp;&mdash; в&nbsp;нём продажи, разбитые по&nbsp;товарным категориям. За&nbsp;первый месяц мы&nbsp;продали машины, компьютеры и&nbsp;программное обеспечение. Во&nbsp;втором машин нет, зато появились велосипеды, а&nbsp;в&nbsp;третьем снова появились машины, но&nbsp;велосипеды исчезли:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; goods_sold = [</span><br><span class="line"><span class="meta">... </span>    &#123;<span class="string">'computers'</span>: <span class="number">10</span>, <span class="string">'cars'</span>: <span class="number">1</span>, <span class="string">'soft'</span>: <span class="number">3</span>&#125;,</span><br><span class="line"><span class="meta">... </span>    &#123;<span class="string">'computers'</span>: <span class="number">4</span>, <span class="string">'soft'</span>: <span class="number">5</span>, <span class="string">'bicycles'</span>: <span class="number">1</span>&#125;,</span><br><span class="line"><span class="meta">... </span>    &#123;<span class="string">'computers'</span>: <span class="number">6</span>, <span class="string">'cars'</span>: <span class="number">2</span>, <span class="string">'soft'</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">... </span>]</span><br></pre></td></tr></table></figure>
<p>Если загрузить данные в&nbsp;датафрейм, Pandas создаст колонки для всех товарных категорий и, где это возможно, заполнит их&nbsp;данными:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; pd.DataFrame(goods_sold)</span><br><span class="line">   bicycles  cars  computers  soft</span><br><span class="line"><span class="number">0</span>       NaN   <span class="number">1.0</span>         <span class="number">10</span>     <span class="number">3</span></span><br><span class="line"><span class="number">1</span>       <span class="number">1.0</span>   NaN          <span class="number">4</span>     <span class="number">5</span></span><br><span class="line"><span class="number">2</span>       NaN   <span class="number">2.0</span>          <span class="number">6</span>     <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>Обратите внимание, продажи велосипедов в&nbsp;первом и&nbsp;третьем месяце равны <code>NaN</code>&nbsp;&mdash; расшифровывается как Not a&nbsp;Number. Так Pandas помечает отсутствующие значения.</p>
<p>Теперь разберем, как загружать данные из&nbsp;файлов. Чаще всего данные хранятся в&nbsp;экселевских таблицах или csv-, tsv- файлах.</p>
<p>Экселевские таблицы читаются с&nbsp;помощью команды <code>pd.read_excel()</code>. Параметрами нужно передать адрес файла на&nbsp;компьютере и&nbsp;название листа, который нужно прочитать. Команда работает как&nbsp;с&nbsp;xls, так и&nbsp;с&nbsp;xlsx:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; pd.read_excel(<span class="string">'file.xlsx'</span>, sheet_name=<span class="string">'Sheet1'</span>)</span><br></pre></td></tr></table></figure>
<p>Файлы формата csv и&nbsp;tsv&nbsp;&mdash; это текстовые файлы, в&nbsp;которых данные отделены друг от&nbsp;друга запятыми или табуляцией:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CSV</span></span><br><span class="line">month,customers,sales</span><br><span class="line">feb,<span class="number">10</span>,<span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TSV</span></span><br><span class="line">month\tcustomers\tsales</span><br><span class="line">feb\t10\t200</span><br></pre></td></tr></table></figure>
<p>Оба читаются с&nbsp;помощью команды <code>.read_csv()</code>, символ табуляции передается параметром <code>sep</code> (от&nbsp;англ. <em>separator</em>&nbsp;&mdash; разделитель):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; pd.read_csv(<span class="string">'file.csv'</span>)</span><br><span class="line">&gt; pd.read_csv(<span class="string">'file.tsv'</span>, sep=<span class="string">'\t'</span>)</span><br></pre></td></tr></table></figure>
<p>При загрузке можно назначить столбец, который будет индексом. Представьте, что мы&nbsp;загружаем таблицу с&nbsp;заказами. У&nbsp;каждого заказа есть свой уникальный номер, Если назначим этот номер индексом, сможем выгружать данные командой <code>df[order_id]</code>. Иначе придется писать фильтр <code>df[df[‘id’] == order_id ]</code>.</p>
<p>О&nbsp;том, как получать данные из&nbsp;датафреймов, я&nbsp;расскажу в&nbsp;одном из&nbsp;следующих разделов. Чтобы назначить колонку индексом, добавим в&nbsp;команду <code>read_csv()</code> параметр <code>index_col</code>, равный названию нужной колонки:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; pd.read_csv(<span class="string">'file.csv'</span>, index_col=<span class="string">'id'</span>)</span><br></pre></td></tr></table></figure>
<p>После загрузки данных в&nbsp;датафрейм, хорошо&nbsp;бы их&nbsp;исследовать&nbsp;&mdash; особенно, если они вам незнакомы.</p>
<h2 id="Исследуем-загруженные-данные"><a href="#Исследуем-загруженные-данные" class="headerlink" title="Исследуем загруженные данные"></a>Исследуем загруженные данные</h2><p>Представим, что мы&nbsp;анализируем продажи американского интернет-магазина. У&nbsp;нас есть данные о&nbsp;заказах и&nbsp;клиентах. Загрузим файл с&nbsp;продажами интернет-магазина в&nbsp;переменную <code>orders</code>. Раз загружаем заказы, укажем, что колонка <code>id</code> пойдет в&nbsp;индекс:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; orders = pd.read_csv(<span class="string">'orders.csv'</span>, index_col=<span class="string">'id'</span>)</span><br></pre></td></tr></table></figure>
<p>Расскажу о&nbsp;четырех атрибутах, которые есть у&nbsp;любого датафрейма: <code>.shape</code>, <code>.columns</code>, <code>.index</code> и&nbsp;<code>.dtypes</code>.</p>
<p><code>.shape</code> показывает, сколько в&nbsp;датафрейме строк и&nbsp;колонок. Он&nbsp;возвращает пару значений <code>(n_rows, n_columns)</code>. Сначала идут строки, потом колонки.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; orders.shape</span><br><span class="line">(<span class="number">5009</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>В&nbsp;датафрейме 5009 строк и&nbsp;5 колонок.</p>
<p>Окей, масштаб оценили. Теперь посмотрим, какая информация содержится в&nbsp;каждой колонке. С&nbsp;помощью <code>.columns</code> узнаем названия колонок:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; orders.columns</span><br><span class="line">Index([<span class="string">'order_date'</span>, <span class="string">'ship_mode'</span>, <span class="string">'customer_id'</span>, <span class="string">'sales'</span>], dtype=<span class="string">'object'</span>)</span><br></pre></td></tr></table></figure>
<p>Теперь видим, что в&nbsp;таблице есть дата заказа, метод доставки, номер клиента и&nbsp;выручка.</p>
<p>С&nbsp;помощью <code>.dtypes</code> узнаем типы данных, находящихся в&nbsp;каждой колонке и&nbsp;поймем, надо&nbsp;ли их&nbsp;обрабатывать. Бывает, что числа загружаются в&nbsp;виде текста. Если мы&nbsp;попробуем сложить две текстовых значения <code>&#39;1&#39; + &#39;1&#39;</code>, то&nbsp;получим не&nbsp;число 2, а&nbsp;строку <code>&#39;11&#39;</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; orders.dtypes</span><br><span class="line">order_date      object</span><br><span class="line">ship_mode       object</span><br><span class="line">customer_id     object</span><br><span class="line">sales          float64</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure>
<p>Тип <code>object</code>&nbsp;&mdash; это текст, <code>float64</code>&nbsp;&mdash; это дробное число типа 3,14.</p>
<p>C&nbsp;помощью атрибута <code>.index</code> посмотрим, как называются строки:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; orders.index</span><br><span class="line">Int64Index([<span class="number">100006</span>, <span class="number">100090</span>, <span class="number">100293</span>, <span class="number">100328</span>, <span class="number">100363</span>, <span class="number">100391</span>, <span class="number">100678</span>, <span class="number">100706</span>,</span><br><span class="line">            <span class="number">100762</span>, <span class="number">100860</span>,</span><br><span class="line">            ...</span><br><span class="line">            <span class="number">167570</span>, <span class="number">167920</span>, <span class="number">168116</span>, <span class="number">168613</span>, <span class="number">168690</span>, <span class="number">168802</span>, <span class="number">169320</span>, <span class="number">169488</span>,</span><br><span class="line">            <span class="number">169502</span>, <span class="number">169551</span>],</span><br><span class="line">           dtype=<span class="string">'int64'</span>, name=<span class="string">'id'</span>, length=<span class="number">5009</span>)</span><br></pre></td></tr></table></figure>
<p>Ожидаемо, в&nbsp;индексе датафрейма номера заказов: 100762, 100860 и&nbsp;так далее.</p>
<p>В&nbsp;колонке <code>sales</code> хранится стоимость каждого проданного товара. Чтобы узнать разброс значений, среднюю стоимость и&nbsp;медиану, используем метод <code>.describe()</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; orders.describe()</span><br><span class="line">         sales</span><br><span class="line">count   <span class="number">5009.0</span></span><br><span class="line">mean     <span class="number">458.6</span></span><br><span class="line">std      <span class="number">954.7</span></span><br><span class="line">min        <span class="number">0.6</span></span><br><span class="line"><span class="number">25</span>%       <span class="number">37.6</span></span><br><span class="line"><span class="number">50</span>%      <span class="number">152.0</span></span><br><span class="line"><span class="number">75</span>%      <span class="number">512.1</span></span><br><span class="line">max    <span class="number">23661.2</span></span><br></pre></td></tr></table></figure>
<p>Наконец, чтобы посмотреть на&nbsp;несколько примеров записей датафрейма, используем команды <code>.head()</code> и&nbsp;<code>.sample()</code>. Первая возвращает 6 записей из&nbsp;начала датафрейма. Вторая&nbsp;&mdash; 6 случайных записей:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; orders.head()</span><br><span class="line">        order_date ship_mode customer_id    sales</span><br><span class="line">id                                                                         </span><br><span class="line"><span class="number">100006</span>  <span class="number">2014</span><span class="number">-09</span><span class="number">-07</span>  Standard    DK<span class="number">-13375</span>  <span class="number">377.970</span></span><br><span class="line"><span class="number">100090</span>  <span class="number">2014</span><span class="number">-07</span><span class="number">-08</span>  Standard    EB<span class="number">-13705</span>  <span class="number">699.192</span></span><br><span class="line"><span class="number">100293</span>  <span class="number">2014</span><span class="number">-03</span><span class="number">-14</span>  Standard    NF<span class="number">-18475</span>   <span class="number">91.056</span></span><br><span class="line"><span class="number">100328</span>  <span class="number">2014</span><span class="number">-01</span><span class="number">-28</span>  Standard    JC<span class="number">-15340</span>    <span class="number">3.928</span></span><br><span class="line"><span class="number">100363</span>  <span class="number">2014</span><span class="number">-04</span><span class="number">-08</span>  Standard    JM<span class="number">-15655</span>   <span class="number">21.376</span></span><br></pre></td></tr></table></figure>
<p>Получив первое представление о&nbsp;датафреймах, теперь обсудим, как доставать из&nbsp;него данные.</p>
<h2 id="Получаем-данные-из-nbsp-датафреймов"><a href="#Получаем-данные-из-nbsp-датафреймов" class="headerlink" title="Получаем данные из&nbsp;датафреймов"></a>Получаем данные из&nbsp;датафреймов</h2><p>Данные из&nbsp;датафреймов можно получать по-разному: указав номера колонок и&nbsp;строк, использовав условные операторы или язык запросов. Расскажу подробнее о&nbsp;каждом способе.</p>
<h3 id="Указываем-нужные-строки-и-nbsp-колонки"><a href="#Указываем-нужные-строки-и-nbsp-колонки" class="headerlink" title="Указываем нужные строки и&nbsp;колонки"></a>Указываем нужные строки и&nbsp;колонки</h3><p>Продолжаем анализировать продажи интернет-магазина, которые загрузили в&nbsp;предыдущем разделе. Допустим, я&nbsp;хочу вывести столбец <code>sales</code>. Для этого название столбца нужно заключить в&nbsp;квадратные скобки и&nbsp;поставить после них названия датафрейма: <code>orders[&#39;sales&#39;]</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; orders[<span class="string">'sales'</span>]</span><br><span class="line">id</span><br><span class="line"><span class="number">100006</span>     <span class="number">377.970</span></span><br><span class="line"><span class="number">100090</span>     <span class="number">699.192</span></span><br><span class="line"><span class="number">100293</span>      <span class="number">91.056</span></span><br><span class="line"><span class="number">100328</span>       <span class="number">3.928</span></span><br><span class="line"><span class="number">100363</span>      <span class="number">21.376</span></span><br><span class="line"><span class="number">100391</span>      <span class="number">14.620</span></span><br><span class="line"><span class="number">100678</span>     <span class="number">697.074</span></span><br><span class="line"><span class="number">100706</span>     <span class="number">129.440</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Обратите внимание, результат команды&nbsp;&mdash; новый датафрейм с&nbsp;таким&nbsp;же индексом.</p>
<p>Если нужно вывести несколько столбцов, в&nbsp;квадратные скобки нужно вставить список с&nbsp;их&nbsp;названиями: <code>orders[[&#39;customer_id&#39;, &#39;sales&#39;]]</code>. Будьте внимательны: квадратные скобки стали двойными. Первые&nbsp;&mdash; от&nbsp;датафрейма, вторые&nbsp;&mdash; от&nbsp;списка:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; orders[[<span class="string">'customer_id'</span>, <span class="string">'sales'</span>]]</span><br><span class="line">       customer_id     sales</span><br><span class="line">id                                  </span><br><span class="line"><span class="number">100006</span>    DK<span class="number">-13375</span>   <span class="number">377.970</span></span><br><span class="line"><span class="number">100090</span>    EB<span class="number">-13705</span>   <span class="number">699.192</span></span><br><span class="line"><span class="number">100293</span>    NF<span class="number">-18475</span>    <span class="number">91.056</span></span><br><span class="line"><span class="number">100328</span>    JC<span class="number">-15340</span>     <span class="number">3.928</span></span><br><span class="line"><span class="number">100363</span>    JM<span class="number">-15655</span>    <span class="number">21.376</span></span><br><span class="line"><span class="number">100391</span>    BW<span class="number">-11065</span>    <span class="number">14.620</span></span><br><span class="line"><span class="number">100363</span>    KM<span class="number">-16720</span>   <span class="number">697.074</span></span><br><span class="line"><span class="number">100706</span>    LE<span class="number">-16810</span>   <span class="number">129.440</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Перейдем к&nbsp;строкам. Их&nbsp;можно фильтровать по&nbsp;индексу и&nbsp;по&nbsp;порядку. Например, мы&nbsp;хотим вывести только заказы 100363, 100391 и&nbsp;100706, для этого есть команда <code>.loc[]</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; show_these_orders = [<span class="string">'100363'</span>, <span class="string">'100363'</span>, <span class="string">'100706'</span>]</span><br><span class="line">&gt; orders.loc[show_these_orders]</span><br><span class="line">        order_date ship_mode customer_id    sales</span><br><span class="line">id                                                             </span><br><span class="line"><span class="number">100363</span>  <span class="number">2014</span><span class="number">-04</span><span class="number">-08</span>  Standard    JM<span class="number">-15655</span>   <span class="number">21.376</span></span><br><span class="line"><span class="number">100363</span>  <span class="number">2014</span><span class="number">-04</span><span class="number">-08</span>  Standard    JM<span class="number">-15655</span>   <span class="number">21.376</span></span><br><span class="line"><span class="number">100706</span>  <span class="number">2014</span><span class="number">-12</span><span class="number">-16</span>    Second    LE<span class="number">-16810</span>  <span class="number">129.440</span></span><br></pre></td></tr></table></figure>
<p>Можно фильтровать датафреймы по&nbsp;колонкам и&nbsp;столбцам одновременно:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; columns = [<span class="string">'customer_id'</span>, <span class="string">'sales'</span>]</span><br><span class="line">&gt; rows = [<span class="string">'100363'</span>, <span class="string">'100363'</span>, <span class="string">'100706'</span>]</span><br><span class="line">&gt; orders.loc[rows][columns]</span><br><span class="line">       customer_id    sales</span><br><span class="line">id                                 </span><br><span class="line"><span class="number">100363</span>    JM<span class="number">-15655</span>   <span class="number">21.376</span></span><br><span class="line"><span class="number">100363</span>    JM<span class="number">-15655</span>   <span class="number">21.376</span></span><br><span class="line"><span class="number">100706</span>    LE<span class="number">-16810</span>  <span class="number">129.440</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Часто вы&nbsp;не&nbsp;знаете заранее номеров заказов, которые вам нужны. Например, если задача&nbsp;&mdash; получить заказы, стоимостью более 1000&nbsp;рублей. Эту задачу удобно решать с&nbsp;помощью условных операторов.</p>
<h3 id="Если-nbsp-mdash-то-Условные-операторы"><a href="#Если-nbsp-mdash-то-Условные-операторы" class="headerlink" title="Если&nbsp;&mdash; то. Условные операторы"></a>Если&nbsp;&mdash; то. Условные операторы</h3><p>Задача: нужно узнать, откуда приходят самые большие заказы. Начнем с&nbsp;того, что достанем все покупки стоимостью более 1000&nbsp;долларов:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; large = orders[<span class="string">'sales'</span>] &gt; <span class="number">1000</span></span><br><span class="line">&gt; orders.loc[large]</span><br><span class="line">        order_date ship_mode customer_id     sales</span><br><span class="line">id                                                             </span><br><span class="line"><span class="number">101931</span>  <span class="number">2014</span><span class="number">-10</span><span class="number">-28</span>     First    TS<span class="number">-21370</span>  <span class="number">1252.602</span></span><br><span class="line"><span class="number">102673</span>  <span class="number">2014</span><span class="number">-11</span><span class="number">-01</span>  Standard    KH<span class="number">-16630</span>  <span class="number">1044.440</span></span><br><span class="line"><span class="number">102988</span>  <span class="number">2014</span><span class="number">-04</span><span class="number">-05</span>    Second    GM<span class="number">-14695</span>  <span class="number">4251.920</span></span><br><span class="line"><span class="number">103100</span>  <span class="number">2014</span><span class="number">-12</span><span class="number">-20</span>     First    AB<span class="number">-10105</span>  <span class="number">1107.660</span></span><br><span class="line"><span class="number">103310</span>  <span class="number">2014</span><span class="number">-05</span><span class="number">-10</span>  Standard    GM<span class="number">-14680</span>  <span class="number">1769.784</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Помните, что в сериях все операции применяются к каждому элементу? Так вот, операция <code>orders[&#39;sales&#39; &gt; 1000</code> идет по каждому элементу серии и, если условие выполняется, возвращает <code>True</code>. Если не выполняется — <code>False</code>. Получившуюся серию мы сохраняем в переменную <code>foo</code>.</p>
<p>Помните, что в&nbsp;сериях все операции применяются к&nbsp;каждому элементу? Так вот, операция <code>orders[&#39;sales&#39;] &amp;gt; 1000</code> идет по&nbsp;каждому элементу серии и, если условие выполняется, возвращает <code>True</code>. Если не&nbsp;выполняется&nbsp;&mdash; <code>False</code>. Получившуюся серию мы&nbsp;сохраняем в&nbsp;переменную <code>filter_large</code>.</p>
<p>Вторая команда фильтрует строки датафрейма с&nbsp;помощью серии. Если элемент <code>filter_large</code> равен <code>True</code>, заказ отобразится, если <code>False</code>&nbsp;&mdash; нет. Результат&nbsp;&mdash; датафрейм с&nbsp;заказами, стоимостью более 1000&nbsp;долларов.</p>
<p>Интересно, сколько дорогих заказов было доставлено первым классом? Добавим в&nbsp;фильтр ещё одно условие:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; large = df[<span class="string">'sales'</span>] &gt; <span class="number">1000</span></span><br><span class="line">&gt; only_first_class = orders[<span class="string">'ship_mode'</span>] == <span class="string">'First'</span></span><br><span class="line">&gt; orders.loc[large &amp; only_first_class]</span><br><span class="line">        order_date ship_mode customer_id     sales</span><br><span class="line">id                                                           </span><br><span class="line"><span class="number">101931</span>  <span class="number">2014</span><span class="number">-10</span><span class="number">-28</span>     First    TS<span class="number">-21370</span>  <span class="number">1252.602</span></span><br><span class="line"><span class="number">103100</span>  <span class="number">2014</span><span class="number">-12</span><span class="number">-20</span>     First    AB<span class="number">-10105</span>  <span class="number">1107.660</span></span><br><span class="line"><span class="number">106726</span>  <span class="number">2014</span><span class="number">-12</span><span class="number">-06</span>     First    RS<span class="number">-19765</span>  <span class="number">1261.330</span></span><br><span class="line"><span class="number">112158</span>  <span class="number">2014</span><span class="number">-12</span><span class="number">-02</span>     First    DP<span class="number">-13165</span>  <span class="number">1050.600</span></span><br><span class="line"><span class="number">116666</span>  <span class="number">2014</span><span class="number">-05</span><span class="number">-08</span>     First    KT<span class="number">-16480</span>  <span class="number">1799.970</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Логика не&nbsp;изменилась. В&nbsp;переменную <code>large_orders</code> сохранили серию, удовлетворяющую условию <code>orders[&#39;sales&#39;] &amp;gt; 1000</code>). В&nbsp;<code>only_first_class</code>&nbsp;&mdash; серию, удовлетворяющую <code>orders[&#39;ship_mode&#39;] == &#39;First&#39;</code>.</p>
<p>Затем объединили обе серии с&nbsp;помощью логического ‘И’: <code>large_orders &amp; only_first_class</code>. Получили новую серию той&nbsp;же длины, в&nbsp;элементах которой <code>True</code> только у&nbsp;заказов стоимостью больше 1000, и&nbsp;с&nbsp;доставкой первым классом. Таких условий может быть сколько угодно.</p>
<h3 id="Язык-запросов"><a href="#Язык-запросов" class="headerlink" title="Язык запросов"></a>Язык запросов</h3><p>Еще один способ решить предыдущую задачу&nbsp;&mdash; использовать язык запросов. Все условия пишем одной строкой <code>&#39;sales &amp;gt; 1000 &amp; ship_mode == &#39;First&#39;</code> и&nbsp;передаем ее&nbsp;в&nbsp;метод <code>.query()</code>. Запрос получается компактнее.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; orders.query(<span class="string">'sales &gt; 1000 &amp; ship_mode == '</span>First<span class="string">')</span></span><br><span class="line"><span class="string">        order_date ship_mode customer_id     sales</span></span><br><span class="line"><span class="string">id                                                           </span></span><br><span class="line"><span class="string">101931  2014-10-28     First    TS-21370  1252.602</span></span><br><span class="line"><span class="string">103100  2014-12-20     First    AB-10105  1107.660</span></span><br><span class="line"><span class="string">106726  2014-12-06     First    RS-19765  1261.330</span></span><br><span class="line"><span class="string">112158  2014-12-02     First    DP-13165  1050.600</span></span><br><span class="line"><span class="string">116666  2014-05-08     First    KT-16480  1799.970</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>
<p>Отдельный кайф: значения для фильтров можно сохранить в&nbsp;отдельной переменной, а&nbsp;в&nbsp;запросе сослаться на&nbsp;нее с&nbsp;помощью символа @: <code>sales &amp;gt; @sales_filter</code>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; sales_filter = <span class="number">1000</span></span><br><span class="line">&gt; ship_mode_filter = <span class="string">'First'</span></span><br><span class="line">&gt; orders.query(<span class="string">'sales &gt; @sales_filter &amp; ship_mode &gt; @ship_mode_filter'</span>)</span><br><span class="line">         order_date ship_mode customer_id     sales</span><br><span class="line">id                                                           </span><br><span class="line"><span class="number">101931</span>  <span class="number">2014</span><span class="number">-10</span><span class="number">-28</span>     First    TS<span class="number">-21370</span>  <span class="number">1252.602</span></span><br><span class="line"><span class="number">103100</span>  <span class="number">2014</span><span class="number">-12</span><span class="number">-20</span>     First    AB<span class="number">-10105</span>  <span class="number">1107.660</span></span><br><span class="line"><span class="number">106726</span>  <span class="number">2014</span><span class="number">-12</span><span class="number">-06</span>     First    RS<span class="number">-19765</span>  <span class="number">1261.330</span></span><br><span class="line"><span class="number">112158</span>  <span class="number">2014</span><span class="number">-12</span><span class="number">-02</span>     First    DP<span class="number">-13165</span>  <span class="number">1050.600</span></span><br><span class="line"><span class="number">116666</span>  <span class="number">2014</span><span class="number">-05</span><span class="number">-08</span>     First    KT<span class="number">-16480</span>  <span class="number">1799.970</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Разобравшись, как получать куски данных из&nbsp;датафрейма, перейдем к&nbsp;тому, как считать агрегированные метрики: количество заказов, суммарную выручку, средний чек, конверсию.</p>
<h2 id="Считаем-производные-метрики"><a href="#Считаем-производные-метрики" class="headerlink" title="Считаем производные метрики"></a>Считаем производные метрики</h2><p>Задача: посчитаем, сколько денег магазин заработал с&nbsp;помощью каждого класса доставки. Начнем с&nbsp;простого&nbsp;&mdash; просуммируем выручку со&nbsp;всех заказов. Для этого используем метод <code>.sum()</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; orders[<span class="string">'sales'</span>].sum()</span><br><span class="line"><span class="number">2297200.8603000003</span></span><br></pre></td></tr></table></figure>
<p>Добавим класс доставки. Перед суммированием сгруппируем данные с&nbsp;помощью метода <code>.groupby()</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; orders.groupby(<span class="string">'ship_mode'</span>)[<span class="string">'sales'</span>].sum()</span><br><span class="line">ship_mode              </span><br><span class="line">First      <span class="number">3.514284e+05</span></span><br><span class="line">Same Day   <span class="number">1.283631e+05</span></span><br><span class="line">Second     <span class="number">4.591936e+05</span></span><br><span class="line">Standard   <span class="number">1.358216e+06</span></span><br></pre></td></tr></table></figure>
<p><code>3.514284e+05</code>&nbsp;&mdash; научный формат вывода чисел. Означает 3.51 * 10<sup>5</sup>. Нам такая точность не&nbsp;нужна, поэтому можем сказать Pandas, чтобы округлял значения до&nbsp;сотых:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; pd.options.display.float_format = <span class="string">'&#123;:,.1f&#125;'</span>.format</span><br><span class="line">&gt; orders.groupby(<span class="string">'ship_mode'</span>)[<span class="string">'sales'</span>].sum()</span><br><span class="line">ship_mode            </span><br><span class="line">First       <span class="number">351</span>,<span class="number">428.4</span></span><br><span class="line">Same Day    <span class="number">128</span>,<span class="number">363.1</span></span><br><span class="line">Second      <span class="number">459</span>,<span class="number">193.6</span></span><br><span class="line">Standard  <span class="number">1</span>,<span class="number">358</span>,<span class="number">215.7</span></span><br></pre></td></tr></table></figure>
<p>Другое дело. Теперь видим сумму выручки по&nbsp;каждому классу доставки. По&nbsp;суммарной выручке неясно, становится лучше или хуже. Добавим разбивку по&nbsp;датам заказа:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; orders.groupby([<span class="string">'ship_mode'</span>, <span class="string">'order_date'</span>])[<span class="string">'sales'</span>].sum()</span><br><span class="line">ship_mode order_date        </span><br><span class="line">First     <span class="number">2014</span><span class="number">-01</span><span class="number">-06</span>    <span class="number">12.8</span></span><br><span class="line">          <span class="number">2014</span><span class="number">-01</span><span class="number">-11</span>     <span class="number">9.9</span></span><br><span class="line">          <span class="number">2014</span><span class="number">-01</span><span class="number">-14</span>    <span class="number">62.0</span></span><br><span class="line">          <span class="number">2014</span><span class="number">-01</span><span class="number">-15</span>   <span class="number">149.9</span></span><br><span class="line">          <span class="number">2014</span><span class="number">-01</span><span class="number">-19</span>   <span class="number">378.6</span></span><br><span class="line">          <span class="number">2014</span><span class="number">-01</span><span class="number">-26</span>   <span class="number">152.6</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Видно, что выручка прыгает ото дня ко&nbsp;дню: иногда 10&nbsp;долларов, а&nbsp;иногда 378. Интересно, это меняется количество заказов или средний чек? Добавим к&nbsp;выборке количество заказов. Для этого вместо <code>.sum()</code> используем метод <code>.agg()</code>, в&nbsp;который передадим список с&nbsp;названиями нужных функций.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; orders.groupby([<span class="string">'ship_mode'</span>, <span class="string">'order_date'</span>])[<span class="string">'sales'</span>].agg([<span class="string">'sum'</span>, <span class="string">'count'</span>])</span><br><span class="line">                       sum  count</span><br><span class="line">ship_mode order_date             </span><br><span class="line">First     <span class="number">2014</span><span class="number">-01</span><span class="number">-06</span>  <span class="number">12.8</span>      <span class="number">1</span></span><br><span class="line">          <span class="number">2014</span><span class="number">-01</span><span class="number">-11</span>   <span class="number">9.9</span>      <span class="number">1</span></span><br><span class="line">          <span class="number">2014</span><span class="number">-01</span><span class="number">-14</span>  <span class="number">62.0</span>      <span class="number">1</span></span><br><span class="line">          <span class="number">2014</span><span class="number">-01</span><span class="number">-15</span> <span class="number">149.9</span>      <span class="number">1</span></span><br><span class="line">          <span class="number">2014</span><span class="number">-01</span><span class="number">-19</span> <span class="number">378.6</span>      <span class="number">1</span></span><br><span class="line">          <span class="number">2014</span><span class="number">-01</span><span class="number">-26</span> <span class="number">152.6</span>      <span class="number">1</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Ого, получается, что это так прыгает средний чек. Интересно, а&nbsp;какой был самый удачный день? Чтобы узнать, отсортируем получившийся датафрейм: выведем 10 самых денежных дней по&nbsp;выручке:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; orders.groupby([<span class="string">'ship_mode'</span>, <span class="string">'order_date'</span>])[<span class="string">'sales'</span>].agg([<span class="string">'sum'</span>]).sort_values(by=<span class="string">'sum'</span>, ascending=<span class="literal">False</span>).head(<span class="number">10</span>)</span><br><span class="line">                          sum</span><br><span class="line">ship_mode order_date         </span><br><span class="line">Standard  <span class="number">2014</span><span class="number">-03</span><span class="number">-18</span> <span class="number">26</span>,<span class="number">908.4</span></span><br><span class="line">          <span class="number">2016</span><span class="number">-10</span><span class="number">-02</span> <span class="number">18</span>,<span class="number">398.2</span></span><br><span class="line">First     <span class="number">2017</span><span class="number">-03</span><span class="number">-23</span> <span class="number">14</span>,<span class="number">299.1</span></span><br><span class="line">Standard  <span class="number">2014</span><span class="number">-09</span><span class="number">-08</span> <span class="number">14</span>,<span class="number">060.4</span></span><br><span class="line">First     <span class="number">2017</span><span class="number">-10</span><span class="number">-22</span> <span class="number">13</span>,<span class="number">716.5</span></span><br><span class="line">Standard  <span class="number">2016</span><span class="number">-12</span><span class="number">-17</span> <span class="number">12</span>,<span class="number">185.1</span></span><br><span class="line">          <span class="number">2017</span><span class="number">-11</span><span class="number">-17</span> <span class="number">12</span>,<span class="number">112.5</span></span><br><span class="line">          <span class="number">2015</span><span class="number">-09</span><span class="number">-17</span> <span class="number">11</span>,<span class="number">467.6</span></span><br><span class="line">          <span class="number">2016</span><span class="number">-05</span><span class="number">-23</span> <span class="number">10</span>,<span class="number">561.0</span></span><br><span class="line">          <span class="number">2014</span><span class="number">-09</span><span class="number">-23</span> <span class="number">10</span>,<span class="number">478.6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Команда разрослась, и&nbsp;её теперь неудобно читать. Чтобы упростить, можно разбить её на&nbsp;несколько строк. В&nbsp;конце каждой строки ставим обратный слеш <code>\</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; orders \</span><br><span class="line"><span class="meta">... </span>.groupby([<span class="string">'ship_mode'</span>, <span class="string">'order_date'</span>])[<span class="string">'sales'</span>] \</span><br><span class="line"><span class="meta">... </span>.agg([<span class="string">'sum'</span>]) \</span><br><span class="line"><span class="meta">... </span>.sort_values(by=<span class="string">'sum'</span>, ascending=<span class="literal">False</span>) \</span><br><span class="line"><span class="meta">... </span>.head(<span class="number">10</span>)</span><br><span class="line">                          sum</span><br><span class="line">ship_mode order_date         </span><br><span class="line">Standard  <span class="number">2014</span><span class="number">-03</span><span class="number">-18</span> <span class="number">26</span>,<span class="number">908.4</span></span><br><span class="line">          <span class="number">2016</span><span class="number">-10</span><span class="number">-02</span> <span class="number">18</span>,<span class="number">398.2</span></span><br><span class="line">First     <span class="number">2017</span><span class="number">-03</span><span class="number">-23</span> <span class="number">14</span>,<span class="number">299.1</span></span><br><span class="line">Standard  <span class="number">2014</span><span class="number">-09</span><span class="number">-08</span> <span class="number">14</span>,<span class="number">060.4</span></span><br><span class="line">First     <span class="number">2017</span><span class="number">-10</span><span class="number">-22</span> <span class="number">13</span>,<span class="number">716.5</span></span><br><span class="line">Standard  <span class="number">2016</span><span class="number">-12</span><span class="number">-17</span> <span class="number">12</span>,<span class="number">185.1</span></span><br><span class="line">          <span class="number">2017</span><span class="number">-11</span><span class="number">-17</span> <span class="number">12</span>,<span class="number">112.5</span></span><br><span class="line">          <span class="number">2015</span><span class="number">-09</span><span class="number">-17</span> <span class="number">11</span>,<span class="number">467.6</span></span><br><span class="line">          <span class="number">2016</span><span class="number">-05</span><span class="number">-23</span> <span class="number">10</span>,<span class="number">561.0</span></span><br><span class="line">          <span class="number">2014</span><span class="number">-09</span><span class="number">-23</span> <span class="number">10</span>,<span class="number">478.6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Видимо, что самый удачный день&nbsp;&mdash; 18&nbsp;марта 2014 года&nbsp;&mdash; магазин заработал 27 тысяч долларов с&nbsp;помощью стандартного класса доставки. Интересно, откуда были клиенты, сделавшие эти заказы? Чтобы узнать, надо объединить данные о&nbsp;заказах с&nbsp;данными о&nbsp;клиентах.</p>
<h2 id="Объединяем-несколько-датафреймов"><a href="#Объединяем-несколько-датафреймов" class="headerlink" title="Объединяем несколько датафреймов"></a>Объединяем несколько датафреймов</h2><p>До&nbsp;сих пор мы&nbsp;смотрели только на&nbsp;таблицу с&nbsp;заказами. Но&nbsp;ведь у&nbsp;нас есть еще данные о&nbsp;клиентах интернет-магазина. Загрузим их&nbsp;в&nbsp;переменную <code>customers</code> и&nbsp;посмотрим, что они собой представляют:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; customers = pd.read_csv(<span class="string">'customers.csv'</span>, index=<span class="string">'id'</span>)</span><br><span class="line">&gt; customers.head()</span><br><span class="line">                     name    segment           state             city</span><br><span class="line">id                                                                   </span><br><span class="line">CG<span class="number">-12520</span>      Claire Gute   Consumer        Kentucky        Henderson</span><br><span class="line">DV<span class="number">-13045</span>  Darrin Van Huff  Corporate      California      Los Angeles</span><br><span class="line">SO<span class="number">-20335</span>   Sean O<span class="string">'Donnell   Consumer         Florida  Fort Lauderdale</span></span><br><span class="line"><span class="string">BH-11710  Brosina Hoffman   Consumer      California      Los Angeles</span></span><br><span class="line"><span class="string">AA-10480     Andrew Allen   Consumer  North Carolina          Concord</span></span><br></pre></td></tr></table></figure>
<p>Мы&nbsp;знаем тип клиента, место его проживания, его имя и&nbsp;имя контактного лица. У&nbsp;каждого клиента есть уникальный номер <code>id</code>. Этот&nbsp;же номер лежит в&nbsp;колонке <code>customer_id</code> таблицы <code>orders</code>. Значит мы&nbsp;можем найти, какие заказы сделал каждый клиент. Например, посмотрим, заказы пользователя <code>CG-12520</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; cust_filter = <span class="string">'CG-12520'</span></span><br><span class="line">&gt; orders.query(<span class="string">'customer_id == @cust_filter'</span>)</span><br><span class="line">                order_date     ship_mode customer_id   sales</span><br><span class="line">id                                                          </span><br><span class="line">CA<span class="number">-2016</span><span class="number">-152156</span>  <span class="number">2016</span><span class="number">-11</span><span class="number">-08</span>  Second    CG<span class="number">-12520</span>  <span class="number">993.90</span></span><br><span class="line">CA<span class="number">-2017</span><span class="number">-164098</span>  <span class="number">2017</span><span class="number">-01</span><span class="number">-26</span>   First    CG<span class="number">-12520</span>   <span class="number">18.16</span></span><br><span class="line">US<span class="number">-2015</span><span class="number">-123918</span>  <span class="number">2015</span><span class="number">-10</span><span class="number">-15</span>      Same Day    CG<span class="number">-12520</span>  <span class="number">136.72</span></span><br></pre></td></tr></table></figure>
<p>Вернемся к&nbsp;задаче из&nbsp;предыдущего раздела: узнать, что за&nbsp;клиенты, которые сделали 18&nbsp;марта заказы со&nbsp;стандартной доставкой. Для этого объединим таблицы с&nbsp;клиентами и&nbsp;заказами. Датафреймы объединяют с&nbsp;помощью методов <code>.concat()</code>, <code>.merge()</code> и&nbsp;<code>.join()</code>. Все они делают одно и&nbsp;то&nbsp;же, но&nbsp;отличаются синтаксисом&nbsp;&mdash; на&nbsp;практике достаточно уметь пользоваться одним из&nbsp;них.</p>
<p>Покажу на&nbsp;примере <code>.merge()</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; new_df = pd.merge(orders, customers, how=<span class="string">'inner'</span>, left_on=<span class="string">'customer_id'</span>, right_index=<span class="literal">True</span>)</span><br><span class="line">&gt; new_df.columns</span><br><span class="line">Index([<span class="string">'order_date'</span>, <span class="string">'ship_mode'</span>, <span class="string">'customer_id'</span>, <span class="string">'sales'</span>, <span class="string">'name'</span>, <span class="string">'segment'</span>,</span><br><span class="line">       <span class="string">'state'</span>, <span class="string">'city'</span>],</span><br><span class="line">      dtype=<span class="string">'object'</span>)</span><br></pre></td></tr></table></figure>
<p>В&nbsp;<code>.merge()</code> я&nbsp;сначала указал названия датафреймов, которые хочу объединить. Затем уточнил, как именно их&nbsp;объединить и&nbsp;какие колонки использовать в&nbsp;качестве ключа.</p>
<p>Ключ&nbsp;&mdash; это колонка, связывающая оба датафрейма. В&nbsp;нашем случае&nbsp;&mdash; номер клиента. В&nbsp;таблице с&nbsp;заказами он&nbsp;в&nbsp;колонке <code>customer_id</code>, а&nbsp;таблице с&nbsp;клиентами&nbsp;&mdash; в&nbsp;индексе. Поэтому в&nbsp;команде мы&nbsp;пишем: <code>left_on=&#39;customer_id&#39;, right_index=True</code>.</p>
<h2 id="Решаем-задачу"><a href="#Решаем-задачу" class="headerlink" title="Решаем задачу"></a>Решаем задачу</h2><p>Закрепим полученный материал, решив задачу. Найдем 5 городов, принесших самую большую выручку в&nbsp;2016 году.</p>
<p>Для начала отфильтруем заказы из&nbsp;2016 года:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; orders_2016 = orders.query(<span class="string">"order_date &gt;= '2016-01-01' &amp; order_date &lt;= '2016-12-31'"</span>)</span><br><span class="line">&gt; orders_2016.head()</span><br><span class="line">       order_date ship_mode customer_id   sales</span><br><span class="line">id                                             </span><br><span class="line"><span class="number">100041</span> <span class="number">2016</span><span class="number">-11</span><span class="number">-20</span>  Standard    BF<span class="number">-10975</span>   <span class="number">328.5</span></span><br><span class="line"><span class="number">100083</span> <span class="number">2016</span><span class="number">-11</span><span class="number">-24</span>  Standard    CD<span class="number">-11980</span>    <span class="number">24.8</span></span><br><span class="line"><span class="number">100153</span> <span class="number">2016</span><span class="number">-12</span><span class="number">-13</span>  Standard    KH<span class="number">-16630</span>    <span class="number">63.9</span></span><br><span class="line"><span class="number">100244</span> <span class="number">2016</span><span class="number">-09</span><span class="number">-20</span>  Standard    GM<span class="number">-14695</span>   <span class="number">475.7</span></span><br><span class="line"><span class="number">100300</span> <span class="number">2016</span><span class="number">-06</span><span class="number">-24</span>    Second    MJ<span class="number">-17740</span> <span class="number">4</span>,<span class="number">823.1</span></span><br></pre></td></tr></table></figure>
<p>Город&nbsp;&mdash; это атрибут пользователей, а&nbsp;не&nbsp;заказов. Добавим информацию о&nbsp;пользователях:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; with_customers_2016 = pd.merge(customers, orders_2016, how=<span class="string">'inner'</span>, left_index=<span class="literal">True</span>, right_on=<span class="string">'customer_id'</span>)</span><br></pre></td></tr></table></figure>
<p>Cруппируем получившийся датафрейм по&nbsp;городам и&nbsp;посчитаем выручку:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; grouped_2016 = with_customers_2016.groupby(<span class="string">'city'</span>)[<span class="string">'sales'</span>].sum()</span><br><span class="line">&gt; grouped_2016.head()</span><br><span class="line">city</span><br><span class="line">Akron               <span class="number">1</span>,<span class="number">763.0</span></span><br><span class="line">Albuquerque           <span class="number">692.9</span></span><br><span class="line">Amarillo              <span class="number">197.2</span></span><br><span class="line">Arlington           <span class="number">5</span>,<span class="number">672.1</span></span><br><span class="line">Arlington Heights      <span class="number">14.1</span></span><br><span class="line">Name: sales, dtype: float64</span><br></pre></td></tr></table></figure>
<p>Отсортируем по&nbsp;убыванию продаж и&nbsp;оставим топ-5:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; top5 = grouped_2016.sort_values(ascending=<span class="literal">False</span>).head(<span class="number">5</span>)</span><br><span class="line">&gt; print(top5)</span><br><span class="line">city</span><br><span class="line">New York City   <span class="number">53</span>,<span class="number">094.1</span></span><br><span class="line">Philadelphia    <span class="number">39</span>,<span class="number">895.5</span></span><br><span class="line">Seattle         <span class="number">33</span>,<span class="number">955.5</span></span><br><span class="line">Los Angeles     <span class="number">33</span>,<span class="number">611.1</span></span><br><span class="line">San Francisco   <span class="number">27</span>,<span class="number">990.0</span></span><br><span class="line">Name: sales, dtype: float64</span><br></pre></td></tr></table></figure>
<p>Готово!</p>
<p>Попробуйте сами:</p>
<p>Возьмите данные о&nbsp;<a href="http://smysl.io/data/pandas/orders.csv">заказах</a> и&nbsp;<a href="http://smysl.io/data/pandas/customers.csv">покупателях</a> и&nbsp;посчитайте:</p>
<ol>
<li>Сколько заказов, отправлено первым классом за&nbsp;последние 5 лет?</li>
<li>Сколько в&nbsp;базе клиентов из&nbsp;Калифорнии?</li>
<li>Сколько заказов они сделали?</li>
<li>Постройте сводную таблицу средних чеков по&nbsp;всем штатам за&nbsp;каждый год.</li>
</ol>
<p>Через некоторое время выложу ответы <a href="https://t.me/kulichevskiy" target="_blank" rel="noopener">в&nbsp;Телеграме</a>. Подписывайтесь, чтобы не&nbsp;пропустить ответы и&nbsp;новые статьи.</p>
<p>До&nbsp;скорого!</p>
<p><em>Кстати, большое спасибо Александру Марфицину за&nbsp;то, что помог отредактировать статью.</em></p>
</div></div></div><footer id="bottom-outer" role="footer"><div id="bottom-inner"><div class="container"><div class="row"><div class="col-md-8 col-sm-12"><p><span>&copy; Алексей Куличевский 2017–2019</span></p></div></div></div></div></footer></div><script src="/lib/jquery-3.2.1.min.js"></script><script src="/js/glow.js"></script><script src="/js/app.js"></script><script src="/js/payment-form.js"> </script></body>