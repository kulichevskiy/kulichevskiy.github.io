<!DOCTYPE html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta property="og:image" content="http://smysl.io/img/pandas/og-fb.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Anonymous+Pro|PT+Mono"><link rel="stylesheet" href="/fonts/font-awesome-4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="/css/glow.css"><link rel="stylesheet" href="/css/lessons-pointer.css"><link rel="stylesheet" href="/css/social-likes_birman.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/landing.css"><link rel="stylesheet" href="/css/blog.css"><link rel="apple-touch-icon-precomposed" sizes="57x57" href="img/favicons/apple-touch-icon-57x57.png"><link rel="apple-touch-icon-precomposed" sizes="114x114" href="img/favicons/apple-touch-icon-114x114.png"><link rel="apple-touch-icon-precomposed" sizes="72x72" href="img/favicons/apple-touch-icon-72x72.png"><link rel="apple-touch-icon-precomposed" sizes="144x144" href="img/favicons/apple-touch-icon-144x144.png"><link rel="apple-touch-icon-precomposed" sizes="60x60" href="img/favicons/apple-touch-icon-60x60.png"><link rel="apple-touch-icon-precomposed" sizes="120x120" href="img/favicons/apple-touch-icon-120x120.png"><link rel="apple-touch-icon-precomposed" sizes="76x76" href="img/favicons/apple-touch-icon-76x76.png"><link rel="apple-touch-icon-precomposed" sizes="152x152" href="img/favicons/apple-touch-icon-152x152.png"><link rel="icon" type="image/png" href="img/favicons/favicon-196x196.png" sizes="196x196"><link rel="icon" type="image/png" href="img/favicons/favicon-96x96.png" sizes="96x96"><link rel="icon" type="image/png" href="img/favicons/favicon-32x32.png" sizes="32x32"><link rel="icon" type="image/png" href="img/favicons/favicon-16x16.png" sizes="16x16"><link rel="icon" type="image/png" href="img/favicons/favicon-128.png" sizes="128x128"><meta name="application-name" content=" "><meta name="msapplication-TileColor" content="#FFFFFF"><meta name="msapplication-TileImage" content="img/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="mg/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="img/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="img/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="img/favicons/mstile-310x310.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="jS-UOFLu8isjqw3UjLkGEP-fD-tG7w7cAMLIeSepC7M"><meta name="yandex-verification" content="3365363b8d7940a9"><link rel="icon" href="http://ono38scfe.bkt.clouddn.com/favicon_tree.ico"><link rel="icon" type="image/png" sizes="16x16" href="undefined"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-MS47VNR');</script><title>Аналитикам: большая шпаргалка по Pandas</title><meta name="generator" content="Hexo 5.3.0"></head><body><!-- - Google Tag Manager (noscript)--><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-MS47VNR" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><!-- - End Google Tag Manager (noscript)--><div class="blog"><div class="container"><div class="row"><div class="col-md-8 col-sm-12"><div class="avatar"><span><a href="/"><img src="https://s.gravatar.com/avatar/e574dc154e694d72dc40e1dc9be17c32?s=80" width="40px" height="40px"></a></span><span class="author_name"> <a href="/">Алексей Куличевский</a><span style="font-family: graphik-regular;">Блог · <a class="header" href="https://t.me/kulichevskiy" target="_blank">Телеграм</a> · <a class="header" href="/courses/data-1">Курс</a></span></span></div></div></div></div><div class="container container_margin"><div class="row"><div class="col-md-8 col-sm-12"><h1>Аналитикам: большая шпаргалка по Pandas</h1><blockquote>
<p>Привет. Я&nbsp;задумывал эту заметку для студентов курса <a target="_blank" rel="noopener" href="https://digitalgod.be/rockstar">Digital Rockstar</a>, на&nbsp;котором мы&nbsp;учим маркетологов автоматизировать свою работу с&nbsp;помощью программирования, но&nbsp;решил поделиться шпаргалкой по&nbsp;Pandas со&nbsp;всеми. Я&nbsp;ожидаю, что читатель умеет писать код на&nbsp;Python хотя&nbsp;бы на&nbsp;минимальном уровне, знает, что такое списки, словари, циклы и&nbsp;функции.</p>
</blockquote>
<ol>
<li><a href="#Что-такое-Pandas-и-зачем-он-нужен">Что такое Pandas и&nbsp;зачем он&nbsp;нужен</a></li>
<li><a href="#Структуры-данных">Структуры данных: серии и&nbsp;датафреймы</a></li>
<li><a href="#Создаем-датафреймы-и-загружаем-в-них-данные">Создаем датафреймы и&nbsp;загружаем в&nbsp;них данные</a></li>
<li><a href="#Исследуем-загруженные-данные">Исследуем загруженные данные</a></li>
<li><a href="#Получаем-данные-из-датафреймов">Получаем данные из&nbsp;датафреймов</a></li>
<li><a href="#Считаем-производные-метрики">Считаем производные метрики</a></li>
<li><a href="#Объединяем-несколько-датафреймов">Объединяем несколько датафреймов</a></li>
<li><a href="#Решаем-задачу">Решаем задачу</a></li>
</ol>
<h2 id="Что-такое-Pandas-и-nbsp-зачем-он-nbsp-нужен"><a href="#Что-такое-Pandas-и-nbsp-зачем-он-nbsp-нужен" class="headerlink" title="Что такое Pandas и&nbsp;зачем он&nbsp;нужен"></a>Что такое Pandas и&nbsp;зачем он&nbsp;нужен</h2><p>Pandas&nbsp;&mdash; это библиотека для работы с&nbsp;данными на&nbsp;Python. Она упрощает жизнь аналитикам: где раньше использовалось 10 строк кода теперь хватит одной.</p>
<p>Например, чтобы прочитать данные из&nbsp;csv, в&nbsp;стандартном Python надо сначала решить, как хранить данные, затем открыть файл, прочитать его построчно, отделить значения друг от&nbsp;друга и&nbsp;очистить данные от&nbsp;специальных символов.</p>
<pre><code>&gt; with open(&#39;file.csv&#39;) as f:
...    content &#x3D; f.readlines()
...    content &#x3D; [x.split(&#39;,&#39;).replace(&#39;\n&#39;,&#39;&#39;) for x in content]</code></pre>
<p>В&nbsp;Pandas всё проще. Во-первых, не&nbsp;нужно думать, как будут храниться данные&nbsp;&mdash; они лежат в&nbsp;датафрейме. Во-вторых, достаточно написать одну команду:</p>
<pre><code>&gt; data &#x3D; pd.read_csv(&#39;file.csv&#39;)</code></pre>
<p>Pandas добавляет в&nbsp;Python новые структуры данных&nbsp;&mdash; серии и&nbsp;датафреймы. Расскажу, что это такое.</p>
<h2 id="Структуры-данных-серии-и-nbsp-датафреймы"><a href="#Структуры-данных-серии-и-nbsp-датафреймы" class="headerlink" title="Структуры данных: серии и&nbsp;датафреймы"></a>Структуры данных: серии и&nbsp;датафреймы</h2><p>Серии&nbsp;&mdash; одномерные массивы данных. Они очень похожи на&nbsp;списки, но&nbsp;отличаются по&nbsp;поведению&nbsp;&mdash; например, операции применяются к&nbsp;списку целиком, а&nbsp;в&nbsp;сериях&nbsp;&mdash; поэлементно.</p>
<p>То&nbsp;есть, если список умножить на&nbsp;2, получите тот&nbsp;же список, повторенный 2 раза.</p>
<pre><code>&gt; vector &#x3D; [1, 2, 3]
&gt; vector * 2
[1, 2, 3, 1, 2, 3]</code></pre>
<p>А если умножить серию, ее длина не изменится, а вот элементы удвоятся.</p>
<pre><code>&gt; import pandas as pd
&gt; series &#x3D; pd.Series([1, 2, 3])
&gt; series * 2
0    2
1    4
2    6
dtype: int64</code></pre>
<p>Обратите внимание на&nbsp;первый столбик вывода. Это индекс, в&nbsp;котором хранятся адреса каждого элемента серии. Каждый элемент потом можно получать, обратившись по&nbsp;нужному адресу.</p>
<pre><code>&gt; series &#x3D; pd.Series([&#39;foo&#39;, &#39;bar&#39;])
&gt; series[0]
&#39;foo&#39;</code></pre>
<p>Еще одно отличие серий от&nbsp;списков&nbsp;&mdash; в&nbsp;качестве индексов можно использовать произвольные значения, это делает данные нагляднее. Представим, что мы&nbsp;анализируем помесячные продажи. Используем в&nbsp;качестве индексов названия месяцев, значениями будет выручка:</p>
<pre><code>&gt; months &#x3D; [&#39;jan&#39;, &#39;feb&#39;, &#39;mar&#39;, &#39;apr&#39;]
&gt; sales &#x3D; [100, 200, 300, 400]
&gt; data &#x3D; pd.Series(data&#x3D;sales, index&#x3D;months)
&gt; data
jan    100
feb    200
mar    300
apr    400
dtype: int64</code></pre>
<p>Теперь можем получать значения каждого месяца:</p>
<pre><code>&gt; data[&#39;feb&#39;]
200</code></pre>
<p>Так как серии&nbsp;&mdash; одномерный массив данных, в&nbsp;них удобно хранить измерения по&nbsp;одному. На&nbsp;практике удобнее группировать данные вместе. Например, если мы&nbsp;анализируем помесячные продажи, полезно видеть не&nbsp;только выручку, но&nbsp;и&nbsp;количество проданных товаров, количество новых клиентов и&nbsp;средний чек. Для этого отлично подходят датафреймы.</p>
<p>Датафреймы&nbsp;&mdash; это таблицы. У&nbsp;их&nbsp;есть строки, колонки и&nbsp;ячейки.</p>
<p>Технически, колонки датафреймов&nbsp;&mdash; это серии. Поскольку в&nbsp;колонках обычно описывают одни и&nbsp;те&nbsp;же объекты, то&nbsp;все колонки делят один и&nbsp;тот&nbsp;же индекс:</p>
<pre><code>&gt; months &#x3D; [&#39;jan&#39;, &#39;feb&#39;, &#39;mar&#39;, &#39;apr&#39;]
&gt; sales &#x3D; {
...    &#39;revenue&#39;:     [100, 200, 300, 400],
...    &#39;items_sold&#39;:  [23, 43, 55, 65],
...    &#39;new_clients&#39;: [10, 20, 30, 40]
...}
&gt; sales_df &#x3D; pd.DataFrame(data&#x3D;sales, index&#x3D;months)
&gt; sales_df
     revenue  items_sold  new_clients
jan      100          23           10
feb      200          43           20
mar      300          55           30
apr      400          65           40</code></pre>
<p>Объясню, как создавать датафреймы и&nbsp;загружать в&nbsp;них данные.</p>
<h2 id="Создаем-датафреймы-и-nbsp-загружаем-данные"><a href="#Создаем-датафреймы-и-nbsp-загружаем-данные" class="headerlink" title="Создаем датафреймы и&nbsp;загружаем данные"></a>Создаем датафреймы и&nbsp;загружаем данные</h2><p>Бывает, что мы&nbsp;не&nbsp;знаем, что собой представляют данные, и&nbsp;не&nbsp;можем задать структуру заранее. Тогда удобно создать пустой датафрейм и&nbsp;позже наполнить его данными.</p>
<pre><code>&gt; df &#x3D; pd.DataFrame()</code></pre>
<p>А&nbsp;иногда данные уже есть, но&nbsp;хранятся в&nbsp;переменной из&nbsp;стандартного Python, например, в&nbsp;словаре. Чтобы получить датафрейм, эту переменную передаем в&nbsp;ту&nbsp;же команду:</p>
<pre><code>&gt; df &#x3D; pd.DataFrame(data&#x3D;sales, index&#x3D;months))</code></pre>
<p>Случается, что в&nbsp;некоторых записях не&nbsp;хватает данных. Например, посмотрите на&nbsp;список <code>goods_sold</code>&nbsp;&mdash; в&nbsp;нём продажи, разбитые по&nbsp;товарным категориям. За&nbsp;первый месяц мы&nbsp;продали машины, компьютеры и&nbsp;программное обеспечение. Во&nbsp;втором машин нет, зато появились велосипеды, а&nbsp;в&nbsp;третьем снова появились машины, но&nbsp;велосипеды исчезли:</p>
<pre><code>&gt; goods_sold &#x3D; [
...     {&#39;computers&#39;: 10, &#39;cars&#39;: 1, &#39;soft&#39;: 3},
...     {&#39;computers&#39;: 4, &#39;soft&#39;: 5, &#39;bicycles&#39;: 1},
...     {&#39;computers&#39;: 6, &#39;cars&#39;: 2, &#39;soft&#39;: 3}
... ]</code></pre>
<p>Если загрузить данные в&nbsp;датафрейм, Pandas создаст колонки для всех товарных категорий и, где это возможно, заполнит их&nbsp;данными:</p>
<pre><code>&gt; pd.DataFrame(goods_sold)
   bicycles  cars  computers  soft
0       NaN   1.0         10     3
1       1.0   NaN          4     5
2       NaN   2.0          6     3</code></pre>
<p>Обратите внимание, продажи велосипедов в&nbsp;первом и&nbsp;третьем месяце равны <code>NaN</code>&nbsp;&mdash; расшифровывается как Not a&nbsp;Number. Так Pandas помечает отсутствующие значения.</p>
<p>Теперь разберем, как загружать данные из&nbsp;файлов. Чаще всего данные хранятся в&nbsp;экселевских таблицах или csv-, tsv- файлах.</p>
<p>Экселевские таблицы читаются с&nbsp;помощью команды <code>pd.read_excel()</code>. Параметрами нужно передать адрес файла на&nbsp;компьютере и&nbsp;название листа, который нужно прочитать. Команда работает как&nbsp;с&nbsp;xls, так и&nbsp;с&nbsp;xlsx:</p>
<pre><code>&gt; pd.read_excel(&#39;file.xlsx&#39;, sheet_name&#x3D;&#39;Sheet1&#39;)</code></pre>
<p>Файлы формата csv и&nbsp;tsv&nbsp;&mdash; это текстовые файлы, в&nbsp;которых данные отделены друг от&nbsp;друга запятыми или табуляцией:</p>
<pre><code># CSV
month,customers,sales
feb,10,200

# TSV
month\tcustomers\tsales
feb\t10\t200</code></pre>
<p>Оба читаются с&nbsp;помощью команды <code>.read_csv()</code>, символ табуляции передается параметром <code>sep</code> (от&nbsp;англ. <em>separator</em>&nbsp;&mdash; разделитель):</p>
<pre><code>&gt; pd.read_csv(&#39;file.csv&#39;)
&gt; pd.read_csv(&#39;file.tsv&#39;, sep&#x3D;&#39;\t&#39;)</code></pre>
<p>При загрузке можно назначить столбец, который будет индексом. Представьте, что мы&nbsp;загружаем таблицу с&nbsp;заказами. У&nbsp;каждого заказа есть свой уникальный номер, Если назначим этот номер индексом, сможем выгружать данные командой <code>df[order_id]</code>. Иначе придется писать фильтр <code>df[df[‘id’] == order_id ]</code>.</p>
<p>О&nbsp;том, как получать данные из&nbsp;датафреймов, я&nbsp;расскажу в&nbsp;одном из&nbsp;следующих разделов. Чтобы назначить колонку индексом, добавим в&nbsp;команду <code>read_csv()</code> параметр <code>index_col</code>, равный названию нужной колонки:</p>
<pre><code>&gt; pd.read_csv(&#39;file.csv&#39;, index_col&#x3D;&#39;id&#39;)</code></pre>
<p>После загрузки данных в&nbsp;датафрейм, хорошо&nbsp;бы их&nbsp;исследовать&nbsp;&mdash; особенно, если они вам незнакомы.</p>
<h2 id="Исследуем-загруженные-данные"><a href="#Исследуем-загруженные-данные" class="headerlink" title="Исследуем загруженные данные"></a>Исследуем загруженные данные</h2><p>Представим, что мы&nbsp;анализируем продажи американского интернет-магазина. У&nbsp;нас есть данные о&nbsp;заказах и&nbsp;клиентах. Загрузим файл с&nbsp;продажами интернет-магазина в&nbsp;переменную <code>orders</code>. Раз загружаем заказы, укажем, что колонка <code>id</code> пойдет в&nbsp;индекс:</p>
<pre><code>&gt; orders &#x3D; pd.read_csv(&#39;orders.csv&#39;, index_col&#x3D;&#39;id&#39;)</code></pre>
<p>Расскажу о&nbsp;четырех атрибутах, которые есть у&nbsp;любого датафрейма: <code>.shape</code>, <code>.columns</code>, <code>.index</code> и&nbsp;<code>.dtypes</code>.</p>
<p><code>.shape</code> показывает, сколько в&nbsp;датафрейме строк и&nbsp;колонок. Он&nbsp;возвращает пару значений <code>(n_rows, n_columns)</code>. Сначала идут строки, потом колонки.</p>
<pre><code>&gt; orders.shape
(5009, 5)</code></pre>
<p>В&nbsp;датафрейме 5009 строк и&nbsp;5 колонок.</p>
<p>Окей, масштаб оценили. Теперь посмотрим, какая информация содержится в&nbsp;каждой колонке. С&nbsp;помощью <code>.columns</code> узнаем названия колонок:</p>
<pre><code>&gt; orders.columns
Index([&#39;order_date&#39;, &#39;ship_mode&#39;, &#39;customer_id&#39;, &#39;sales&#39;], dtype&#x3D;&#39;object&#39;)</code></pre>
<p>Теперь видим, что в&nbsp;таблице есть дата заказа, метод доставки, номер клиента и&nbsp;выручка.</p>
<p>С&nbsp;помощью <code>.dtypes</code> узнаем типы данных, находящихся в&nbsp;каждой колонке и&nbsp;поймем, надо&nbsp;ли их&nbsp;обрабатывать. Бывает, что числа загружаются в&nbsp;виде текста. Если мы&nbsp;попробуем сложить две текстовых значения <code>&#39;1&#39; + &#39;1&#39;</code>, то&nbsp;получим не&nbsp;число 2, а&nbsp;строку <code>&#39;11&#39;</code>:</p>
<pre><code>&gt; orders.dtypes
order_date      object
ship_mode       object
customer_id     object
sales          float64
dtype: object</code></pre>
<p>Тип <code>object</code>&nbsp;&mdash; это текст, <code>float64</code>&nbsp;&mdash; это дробное число типа 3,14.</p>
<p>C&nbsp;помощью атрибута <code>.index</code> посмотрим, как называются строки:</p>
<pre><code>&gt; orders.index
Int64Index([100006, 100090, 100293, 100328, 100363, 100391, 100678, 100706,
            100762, 100860,
            ...
            167570, 167920, 168116, 168613, 168690, 168802, 169320, 169488,
            169502, 169551],
           dtype&#x3D;&#39;int64&#39;, name&#x3D;&#39;id&#39;, length&#x3D;5009)</code></pre>
<p>Ожидаемо, в&nbsp;индексе датафрейма номера заказов: 100762, 100860 и&nbsp;так далее.</p>
<p>В&nbsp;колонке <code>sales</code> хранится стоимость каждого проданного товара. Чтобы узнать разброс значений, среднюю стоимость и&nbsp;медиану, используем метод <code>.describe()</code>:</p>
<pre><code>&gt; orders.describe()
         sales
count   5009.0
mean     458.6
std      954.7
min        0.6
25%       37.6
50%      152.0
75%      512.1
max    23661.2</code></pre>
<p>Наконец, чтобы посмотреть на&nbsp;несколько примеров записей датафрейма, используем команды <code>.head()</code> и&nbsp;<code>.sample()</code>. Первая возвращает 6 записей из&nbsp;начала датафрейма. Вторая&nbsp;&mdash; 6 случайных записей:</p>
<pre><code>&gt; orders.head()
        order_date ship_mode customer_id    sales
id                                                                         
100006  2014-09-07  Standard    DK-13375  377.970
100090  2014-07-08  Standard    EB-13705  699.192
100293  2014-03-14  Standard    NF-18475   91.056
100328  2014-01-28  Standard    JC-15340    3.928
100363  2014-04-08  Standard    JM-15655   21.376</code></pre>
<p>Получив первое представление о&nbsp;датафреймах, теперь обсудим, как доставать из&nbsp;него данные.</p>
<h2 id="Получаем-данные-из-nbsp-датафреймов"><a href="#Получаем-данные-из-nbsp-датафреймов" class="headerlink" title="Получаем данные из&nbsp;датафреймов"></a>Получаем данные из&nbsp;датафреймов</h2><p>Данные из&nbsp;датафреймов можно получать по-разному: указав номера колонок и&nbsp;строк, использовав условные операторы или язык запросов. Расскажу подробнее о&nbsp;каждом способе.</p>
<h3 id="Указываем-нужные-строки-и-nbsp-колонки"><a href="#Указываем-нужные-строки-и-nbsp-колонки" class="headerlink" title="Указываем нужные строки и&nbsp;колонки"></a>Указываем нужные строки и&nbsp;колонки</h3><p>Продолжаем анализировать продажи интернет-магазина, которые загрузили в&nbsp;предыдущем разделе. Допустим, я&nbsp;хочу вывести столбец <code>sales</code>. Для этого название столбца нужно заключить в&nbsp;квадратные скобки и&nbsp;поставить после них названия датафрейма: <code>orders[&#39;sales&#39;]</code>:</p>
<pre><code>&gt; orders[&#39;sales&#39;]
id
100006     377.970
100090     699.192
100293      91.056
100328       3.928
100363      21.376
100391      14.620
100678     697.074
100706     129.440
...</code></pre>
<p>Обратите внимание, результат команды&nbsp;&mdash; новый датафрейм с&nbsp;таким&nbsp;же индексом.</p>
<p>Если нужно вывести несколько столбцов, в&nbsp;квадратные скобки нужно вставить список с&nbsp;их&nbsp;названиями: <code>orders[[&#39;customer_id&#39;, &#39;sales&#39;]]</code>. Будьте внимательны: квадратные скобки стали двойными. Первые&nbsp;&mdash; от&nbsp;датафрейма, вторые&nbsp;&mdash; от&nbsp;списка:</p>
<pre><code>&gt; orders[[&#39;customer_id&#39;, &#39;sales&#39;]]
       customer_id     sales
id                                  
100006    DK-13375   377.970
100090    EB-13705   699.192
100293    NF-18475    91.056
100328    JC-15340     3.928
100363    JM-15655    21.376
100391    BW-11065    14.620
100363    KM-16720   697.074
100706    LE-16810   129.440
...</code></pre>
<p>Перейдем к&nbsp;строкам. Их&nbsp;можно фильтровать по&nbsp;индексу и&nbsp;по&nbsp;порядку. Например, мы&nbsp;хотим вывести только заказы 100363, 100391 и&nbsp;100706, для этого есть команда <code>.loc[]</code>:</p>
<pre><code>&gt; show_these_orders &#x3D; [&#39;100363&#39;, &#39;100363&#39;, &#39;100706&#39;]
&gt; orders.loc[show_these_orders]
        order_date ship_mode customer_id    sales
id                                                             
100363  2014-04-08  Standard    JM-15655   21.376
100363  2014-04-08  Standard    JM-15655   21.376
100706  2014-12-16    Second    LE-16810  129.440</code></pre>
<p>А в другой раз бывает нужно достать просто заказы с 1 по 3 по порядку, вне зависимости от их номеров в таблицемы. Тогда используют команду <code>.iloc[]</code>:</p>
<pre><code>&gt; show_these_orders &#x3D; [1, 2, 3]
&gt; orders.iloc[show_these_orders]
        order_date ship_mode customer_id    sales
id                                                             
100090  2014-04-08  Standard    JM-15655   21.376
100293  2014-04-08  Standard    JM-15655   21.376
100328  2014-12-16    Second    LE-16810  129.440</code></pre>
<p>Можно фильтровать датафреймы по&nbsp;колонкам и&nbsp;столбцам одновременно:</p>
<pre><code>&gt; columns &#x3D; [&#39;customer_id&#39;, &#39;sales&#39;]
&gt; rows &#x3D; [&#39;100363&#39;, &#39;100363&#39;, &#39;100706&#39;]
&gt; orders.loc[rows][columns]
       customer_id    sales
id                                 
100363    JM-15655   21.376
100363    JM-15655   21.376
100706    LE-16810  129.440
...</code></pre>
<p>Часто вы&nbsp;не&nbsp;знаете заранее номеров заказов, которые вам нужны. Например, если задача&nbsp;&mdash; получить заказы, стоимостью более 1000&nbsp;рублей. Эту задачу удобно решать с&nbsp;помощью условных операторов.</p>
<h3 id="Если-nbsp-mdash-то-Условные-операторы"><a href="#Если-nbsp-mdash-то-Условные-операторы" class="headerlink" title="Если&nbsp;&mdash; то. Условные операторы"></a>Если&nbsp;&mdash; то. Условные операторы</h3><p>Задача: нужно узнать, откуда приходят самые большие заказы. Начнем с&nbsp;того, что достанем все покупки стоимостью более 1000&nbsp;долларов:</p>
<pre><code>&gt; filter_large &#x3D; orders[&#39;sales&#39;] &gt; 1000
&gt; orders.loc[filter_slarge]
        order_date ship_mode customer_id     sales
id                                                             
101931  2014-10-28     First    TS-21370  1252.602
102673  2014-11-01  Standard    KH-16630  1044.440
102988  2014-04-05    Second    GM-14695  4251.920
103100  2014-12-20     First    AB-10105  1107.660
103310  2014-05-10  Standard    GM-14680  1769.784
...</code></pre>
<p>Помните, в&nbsp;начале статьи я&nbsp;упоминал, что в&nbsp;сериях все операции применяются по-элементно? Так вот, операция <code>orders[&#39;sales&#39;] &gt; 1000</code> идет по&nbsp;каждому элементу серии и, если условие выполняется, возвращает <code>True</code>. Если не&nbsp;выполняется&nbsp;&mdash; <code>False</code>. Получившуюся серию мы&nbsp;сохраняем в&nbsp;переменную <code>filter_large</code>.</p>
<p>Вторая команда фильтрует строки датафрейма с&nbsp;помощью серии. Если элемент <code>filter_large</code> равен <code>True</code>, заказ отобразится, если <code>False</code>&nbsp;&mdash; нет. Результат&nbsp;&mdash; датафрейм с&nbsp;заказами, стоимостью более 1000&nbsp;долларов.</p>
<p>Интересно, сколько дорогих заказов было доставлено первым классом? Добавим в&nbsp;фильтр ещё одно условие:</p>
<pre><code>&gt; filter_large &#x3D; df[&#39;sales&#39;] &gt; 1000
&gt; filter_first_class &#x3D; orders[&#39;ship_mode&#39;] &#x3D;&#x3D; &#39;First&#39;
&gt; orders.loc[filter_large &amp; filter_first_class]
        order_date ship_mode customer_id     sales
id                                                           
101931  2014-10-28     First    TS-21370  1252.602
103100  2014-12-20     First    AB-10105  1107.660
106726  2014-12-06     First    RS-19765  1261.330
112158  2014-12-02     First    DP-13165  1050.600
116666  2014-05-08     First    KT-16480  1799.970
...</code></pre>
<p>Логика не&nbsp;изменилась. В&nbsp;переменную <code>filter_large</code> сохранили серию, удовлетворяющую условию <code>orders[&#39;sales&#39;] &gt; 1000</code>. В&nbsp;<code>filter_first_class</code>&nbsp;&mdash; серию, удовлетворяющую <code>orders[&#39;ship_mode&#39;] == &#39;First&#39;</code>.</p>
<p>Затем объединили обе серии с&nbsp;помощью логического ‘И’: <code>filter_first_class &amp; filter_first_class</code>. Получили новую серию той&nbsp;же длины, в&nbsp;элементах которой <code>True</code> только у&nbsp;заказов, стоимостью больше 1000, доставленных первым классом. Таких условий может быть сколько угодно.</p>
<h3 id="Язык-запросов"><a href="#Язык-запросов" class="headerlink" title="Язык запросов"></a>Язык запросов</h3><p>Еще один способ решить предыдущую задачу&nbsp;&mdash; использовать язык запросов. Все условия пишем одной строкой <code>&#39;sales &gt; 1000 &amp; ship_mode == &#39;First&#39;</code> и&nbsp;передаем ее&nbsp;в&nbsp;метод <code>.query()</code>. Запрос получается компактнее.</p>
<pre><code>&gt; orders.query(&#39;sales &gt; 1000 &amp; ship_mode &#x3D;&#x3D; First&#39;)
        order_date ship_mode customer_id     sales
id                                                           
101931  2014-10-28     First    TS-21370  1252.602
103100  2014-12-20     First    AB-10105  1107.660
106726  2014-12-06     First    RS-19765  1261.330
112158  2014-12-02     First    DP-13165  1050.600
116666  2014-05-08     First    KT-16480  1799.970
...</code></pre>
<p>Отдельный кайф: значения для фильтров можно сохранить в&nbsp;переменной, а&nbsp;в&nbsp;запросе сослаться на&nbsp;нее с&nbsp;помощью символа @: <code>sales &gt; @sales_filter</code>.</p>
<pre><code>&gt; sales_filter &#x3D; 1000
&gt; ship_mode_filter &#x3D; &#39;First&#39;
&gt; orders.query(&#39;sales &gt; @sales_filter &amp; ship_mode &gt; @ship_mode_filter&#39;)
         order_date ship_mode customer_id     sales
id                                                           
101931  2014-10-28     First    TS-21370  1252.602
103100  2014-12-20     First    AB-10105  1107.660
106726  2014-12-06     First    RS-19765  1261.330
112158  2014-12-02     First    DP-13165  1050.600
116666  2014-05-08     First    KT-16480  1799.970
...</code></pre>
<p>Разобравшись, как получать куски данных из&nbsp;датафрейма, перейдем к&nbsp;тому, как считать агрегированные метрики: количество заказов, суммарную выручку, средний чек, конверсию.</p>
<h2 id="Считаем-производные-метрики"><a href="#Считаем-производные-метрики" class="headerlink" title="Считаем производные метрики"></a>Считаем производные метрики</h2><p>Задача: посчитаем, сколько денег магазин заработал с&nbsp;помощью каждого класса доставки. Начнем с&nbsp;простого&nbsp;&mdash; просуммируем выручку со&nbsp;всех заказов. Для этого используем метод <code>.sum()</code>:</p>
<pre><code>&gt; orders[&#39;sales&#39;].sum()
2297200.8603000003</code></pre>
<p>Добавим класс доставки. Перед суммированием сгруппируем данные с&nbsp;помощью метода <code>.groupby()</code>:</p>
<pre><code>&gt; orders.groupby(&#39;ship_mode&#39;)[&#39;sales&#39;].sum()
ship_mode              
First      3.514284e+05
Same Day   1.283631e+05
Second     4.591936e+05
Standard   1.358216e+06</code></pre>
<p><code>3.514284e+05</code>&nbsp;&mdash; научный формат вывода чисел. Означает 3.51 * 10<sup>5</sup>. Нам такая точность не&nbsp;нужна, поэтому можем сказать Pandas, чтобы округлял значения до&nbsp;сотых:</p>
<pre><code>&gt; pd.options.display.float_format &#x3D; &#39;{:,.1f}&#39;.format
&gt; orders.groupby(&#39;ship_mode&#39;)[&#39;sales&#39;].sum()
ship_mode            
First       351,428.4
Same Day    128,363.1
Second      459,193.6
Standard  1,358,215.7</code></pre>
<p>Другое дело. Теперь видим сумму выручки по&nbsp;каждому классу доставки. По&nbsp;суммарной выручке неясно, становится лучше или хуже. Добавим разбивку по&nbsp;датам заказа:</p>
<pre><code>&gt; orders.groupby([&#39;ship_mode&#39;, &#39;order_date&#39;])[&#39;sales&#39;].sum()
ship_mode order_date        
First     2014-01-06    12.8
          2014-01-11     9.9
          2014-01-14    62.0
          2014-01-15   149.9
          2014-01-19   378.6
          2014-01-26   152.6
...</code></pre>
<p>Видно, что выручка прыгает ото дня ко&nbsp;дню: иногда 10&nbsp;долларов, а&nbsp;иногда 378. Интересно, это меняется количество заказов или средний чек? Добавим к&nbsp;выборке количество заказов. Для этого вместо <code>.sum()</code> используем метод <code>.agg()</code>, в&nbsp;который передадим список с&nbsp;названиями нужных функций.</p>
<pre><code>&gt; orders.groupby([&#39;ship_mode&#39;, &#39;order_date&#39;])[&#39;sales&#39;].agg([&#39;sum&#39;, &#39;count&#39;])
                       sum  count
ship_mode order_date             
First     2014-01-06  12.8      1
          2014-01-11   9.9      1
          2014-01-14  62.0      1
          2014-01-15 149.9      1
          2014-01-19 378.6      1
          2014-01-26 152.6      1
...</code></pre>
<p>Ого, получается, что это так прыгает средний чек. Интересно, а&nbsp;какой был самый удачный день? Чтобы узнать, отсортируем получившийся датафрейм: выведем 10 самых денежных дней по&nbsp;выручке:</p>
<pre><code>&gt; orders.groupby([&#39;ship_mode&#39;, &#39;order_date&#39;])[&#39;sales&#39;].agg([&#39;sum&#39;]).sort_values(by&#x3D;&#39;sum&#39;, ascending&#x3D;False).head(10)
                          sum
ship_mode order_date         
Standard  2014-03-18 26,908.4
          2016-10-02 18,398.2
First     2017-03-23 14,299.1
Standard  2014-09-08 14,060.4
First     2017-10-22 13,716.5
Standard  2016-12-17 12,185.1
          2017-11-17 12,112.5
          2015-09-17 11,467.6
          2016-05-23 10,561.0
          2014-09-23 10,478.6
</code></pre>
<p>Команда разрослась, и&nbsp;её теперь неудобно читать. Чтобы упростить, можно разбить её на&nbsp;несколько строк. В&nbsp;конце каждой строки ставим обратный слеш <code>\</code>:</p>
<pre><code>&gt; orders \
... .groupby([&#39;ship_mode&#39;, &#39;order_date&#39;])[&#39;sales&#39;] \
... .agg([&#39;sum&#39;]) \
... .sort_values(by&#x3D;&#39;sum&#39;, ascending&#x3D;False) \
... .head(10)
                          sum
ship_mode order_date         
Standard  2014-03-18 26,908.4
          2016-10-02 18,398.2
First     2017-03-23 14,299.1
Standard  2014-09-08 14,060.4
First     2017-10-22 13,716.5
Standard  2016-12-17 12,185.1
          2017-11-17 12,112.5
          2015-09-17 11,467.6
          2016-05-23 10,561.0
          2014-09-23 10,478.6
</code></pre>
<p>В самый удачный день&nbsp;&mdash; 18&nbsp;марта 2014 года&nbsp;&mdash; магазин заработал 27 тысяч долларов с&nbsp;помощью стандартного класса доставки. Интересно, откуда были клиенты, сделавшие эти заказы? Чтобы узнать, надо объединить данные о&nbsp;заказах с&nbsp;данными о&nbsp;клиентах.</p>
<h2 id="Объединяем-несколько-датафреймов"><a href="#Объединяем-несколько-датафреймов" class="headerlink" title="Объединяем несколько датафреймов"></a>Объединяем несколько датафреймов</h2><p>До&nbsp;сих пор мы&nbsp;смотрели только на&nbsp;таблицу с&nbsp;заказами. Но&nbsp;ведь у&nbsp;нас есть еще данные о&nbsp;клиентах интернет-магазина. Загрузим их&nbsp;в&nbsp;переменную <code>customers</code> и&nbsp;посмотрим, что они собой представляют:</p>
<pre><code>&gt; customers &#x3D; pd.read_csv(&#39;customers.csv&#39;, index&#x3D;&#39;id&#39;)
&gt; customers.head()
                     name    segment           state             city
id                                                                   
CG-12520      Claire Gute   Consumer        Kentucky        Henderson
DV-13045  Darrin Van Huff  Corporate      California      Los Angeles
SO-20335   Sean O&#39;Donnell   Consumer         Florida  Fort Lauderdale
BH-11710  Brosina Hoffman   Consumer      California      Los Angeles
AA-10480     Andrew Allen   Consumer  North Carolina          Concord</code></pre>
<p>Мы&nbsp;знаем тип клиента, место его проживания, его имя и&nbsp;имя контактного лица. У&nbsp;каждого клиента есть уникальный номер <code>id</code>. Этот&nbsp;же номер лежит в&nbsp;колонке <code>customer_id</code> таблицы <code>orders</code>. Значит мы&nbsp;можем найти, какие заказы сделал каждый клиент. Например, посмотрим, заказы пользователя <code>CG-12520</code>:</p>
<pre><code>&gt; cust_filter &#x3D; &#39;CG-12520&#39;
&gt; orders.query(&#39;customer_id &#x3D;&#x3D; @cust_filter&#39;)
                order_date ship_mode customer_id   sales
id                                                          
CA-2016-152156  2016-11-08    Second    CG-12520  993.90
CA-2017-164098  2017-01-26     First    CG-12520   18.16
US-2015-123918  2015-10-15  Same Day    CG-12520  136.72</code></pre>
<p>Вернемся к&nbsp;задаче из&nbsp;предыдущего раздела: узнать, что за&nbsp;клиенты, которые сделали 18&nbsp;марта заказы со&nbsp;стандартной доставкой. Для этого объединим таблицы с&nbsp;клиентами и&nbsp;заказами. Датафреймы объединяют с&nbsp;помощью методов <code>.concat()</code>, <code>.merge()</code> и&nbsp;<code>.join()</code>. Все они делают одно и&nbsp;то&nbsp;же, но&nbsp;отличаются синтаксисом&nbsp;&mdash; на&nbsp;практике достаточно уметь пользоваться одним из&nbsp;них.</p>
<p>Покажу на&nbsp;примере <code>.merge()</code>:</p>
<pre><code>&gt; new_df &#x3D; pd.merge(orders, customers, how&#x3D;&#39;inner&#39;, left_on&#x3D;&#39;customer_id&#39;, right_index&#x3D;True)
&gt; new_df.columns
Index([&#39;order_date&#39;, &#39;ship_mode&#39;, &#39;customer_id&#39;, &#39;sales&#39;, &#39;name&#39;, &#39;segment&#39;,
       &#39;state&#39;, &#39;city&#39;],
      dtype&#x3D;&#39;object&#39;)</code></pre>
<p>В&nbsp;<code>.merge()</code> я&nbsp;сначала указал названия датафреймов, которые хочу объединить. Затем уточнил, как именно их&nbsp;объединить и&nbsp;какие колонки использовать в&nbsp;качестве ключа.</p>
<p>Ключ&nbsp;&mdash; это колонка, связывающая оба датафрейма. В&nbsp;нашем случае&nbsp;&mdash; номер клиента. В&nbsp;таблице с&nbsp;заказами он&nbsp;в&nbsp;колонке <code>customer_id</code>, а&nbsp;таблице с&nbsp;клиентами&nbsp;&mdash; в&nbsp;индексе. Поэтому в&nbsp;команде мы&nbsp;пишем: <code>left_on=&#39;customer_id&#39;, right_index=True</code>.</p>
<h2 id="Решаем-задачу"><a href="#Решаем-задачу" class="headerlink" title="Решаем задачу"></a>Решаем задачу</h2><p>Закрепим полученный материал, решив задачу. Найдем 5 городов, принесших самую большую выручку в&nbsp;2016 году.</p>
<p>Для начала отфильтруем заказы из&nbsp;2016 года:</p>
<pre><code>&gt; orders_2016 &#x3D; orders.query(&quot;order_date &gt;&#x3D; &#39;2016-01-01&#39; &amp; order_date &lt;&#x3D; &#39;2016-12-31&#39;&quot;)
&gt; orders_2016.head()
       order_date ship_mode customer_id   sales
id                                             
100041 2016-11-20  Standard    BF-10975   328.5
100083 2016-11-24  Standard    CD-11980    24.8
100153 2016-12-13  Standard    KH-16630    63.9
100244 2016-09-20  Standard    GM-14695   475.7
100300 2016-06-24    Second    MJ-17740 4,823.1</code></pre>
<p>Город&nbsp;&mdash; это атрибут пользователей, а&nbsp;не&nbsp;заказов. Добавим информацию о&nbsp;пользователях:</p>
<pre><code>&gt; with_customers_2016 &#x3D; pd.merge(customers, orders_2016, how&#x3D;&#39;inner&#39;, left_index&#x3D;True, right_on&#x3D;&#39;customer_id&#39;)</code></pre>
<p>Cруппируем получившийся датафрейм по&nbsp;городам и&nbsp;посчитаем выручку:</p>
<pre><code>&gt; grouped_2016 &#x3D; with_customers_2016.groupby(&#39;city&#39;)[&#39;sales&#39;].sum()
&gt; grouped_2016.head()
city
Akron               1,763.0
Albuquerque           692.9
Amarillo              197.2
Arlington           5,672.1
Arlington Heights      14.1
Name: sales, dtype: float64</code></pre>
<p>Отсортируем по&nbsp;убыванию продаж и&nbsp;оставим топ-5:</p>
<pre><code>&gt; top5 &#x3D; grouped_2016.sort_values(ascending&#x3D;False).head(5)
&gt; print(top5)
city
New York City   53,094.1
Philadelphia    39,895.5
Seattle         33,955.5
Los Angeles     33,611.1
San Francisco   27,990.0
Name: sales, dtype: float64</code></pre>
<p>Готово!</p>
<p>Попробуйте сами:</p>
<p>Возьмите данные о&nbsp;<a href="http://smysl.io/data/pandas/orders.csv">заказах</a> и&nbsp;<a href="http://smysl.io/data/pandas/customers.csv">покупателях</a> и&nbsp;посчитайте:</p>
<ol>
<li>Сколько заказов, отправлено первым классом за&nbsp;последние 5 лет?</li>
<li>Сколько в&nbsp;базе клиентов из&nbsp;Калифорнии?</li>
<li>Сколько заказов они сделали?</li>
<li>Постройте сводную таблицу средних чеков по&nbsp;всем штатам за&nbsp;каждый год.</li>
</ol>
<p>Через некоторое время выложу ответы <a target="_blank" rel="noopener" href="https://t.me/kulichevskiy">в&nbsp;Телеграме</a>. Подписывайтесь, чтобы не&nbsp;пропустить ответы и&nbsp;новые статьи.</p>
<p>До&nbsp;скорого!</p>
<p><em>Кстати, большое спасибо Александру Марфицину за&nbsp;то, что помог отредактировать статью.</em></p>
</div></div><div class="row"><div class="col-md-8 col-sm-12"><div class="shared"><p class="small-text">Поделитесь со знакомыми аналитиками:</p><div class="shared__pic"><!-- <img src="img/shared.png" width="470">--><div class="social-likes"><div class="facebook" title="Поделиться ссылкой на Фейсбуке">Поделиться</div><div class="twitter" title="Поделиться ссылкой в Твиттере">Твитнуть</div><div class="vkontakte" title="Поделиться ссылкой во Вконтакте">Поделиться</div><div class="odnoklassniki" title="Поделиться ссылкой во Одноклассниках">Класснуть</div></div></div></div></div></div></div><footer id="bottom-outer" role="footer"><div id="bottom-inner"><div class="container"><div class="row"><div class="col-md-8 col-sm-12"><p><span>&copy; Алексей Куличевский 2017–2021</span></p></div></div></div></div></footer></div><script src="/lib/jquery-3.2.1.min.js"></script><script src="/js/glow.js"></script><script src="/js/app.js"></script><script src="/js/payment-form.js"> </script></body>